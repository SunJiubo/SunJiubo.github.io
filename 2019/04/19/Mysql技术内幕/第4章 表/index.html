<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">
<meta property="og:type" content="article">
<meta property="og:title" content="弟4章 表">
<meta property="og:url" content="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/index.html">
<meta property="og:site_name" content="NineBoy&#39;s Blog">
<meta property="og:description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-22T14:17:03.577Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="弟4章 表">
<meta name="twitter:description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/">





  <title>弟4章 表 | NineBoy's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NineBoy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="孙九博">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/quan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NineBoy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">弟4章 表</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-19T20:10:15+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="弟4章-表"><a href="#弟4章-表" class="headerlink" title="弟4章 表"></a>弟4章 表</h2><h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。</span><br><span class="line">如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。</span><br></pre></td></tr></table></figure></p>
<p><strong>当表中有多个非空唯一索引时，InnoDB将选择建表时第一个定义的非空唯一索引为主键。这里需要注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE z (</span><br><span class="line">    -&gt; a INT NOT NULL,</span><br><span class="line">    -&gt; b INT NULL,</span><br><span class="line">    -&gt; c INT NOT NULL,</span><br><span class="line">    -&gt; d INT NOT NULL,</span><br><span class="line">    -&gt; UNIQUE KEY (b),</span><br><span class="line">    -&gt; UNIQUE KEY (d), UNIQUE KEY (c)); # d是主键，b不是非空的，a不是唯一的，d排在c前边</span><br></pre></td></tr></table></figure>
<p>因为d列首先定义为一个唯一索引，故InnoDB将其视为主键。</p>
<p>_rowid可以显示表的主键，因此通过上述查询可以找到表z的主键。 另外需要注意的是，_rowid只能用于查看单个列为主键的情况，对于多列组成的键就显得无能为力了。 </p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也成为块（block）。</p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>如果启用了innodb_file_per_table的参数，每张表内的数据可以单独放到一个表空间，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息、二次写缓冲（Double write buffer）等还是存放在原来的共享表空间中。</p>
<p>接着执行会产生大量undo操作的语句update mytest set salary=0，完成后再观察共享表空间，会发现ibdata1已经增长到了114MB。（有更新操作，自然就要记录undo信息）这个例子虽然简单，但是足以说明共享表空间中还包含有undo信息。</p>
<p>很“可惜”，共享表空间的大小还是114MB，即InnoDB不会再执行rollback时去收缩这个表空间。虽然InnoDB不会回收这些空间，但是会自动判断这些undo信息是否还需要，如果不需要，则会将这些空间标记为可用空间，供下次undo使用。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。因为前面已经介绍过了InnoDB表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点（Leaf node segment），索引段即为B+树的非索引节点（Non-leaf node segment）。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB一次从磁盘申请4~5个区。在默认情况下，InnoDB页的大小为16KB，即一个区中一共有64个连续的页。无论页的大小怎么变化，区的大小总是1M。</p>
<p>但是，这里还有一个问题：在用户启用了参数innodb_file_per_table后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页（fragment page）来存放数据，在使用完这些页之后才是64个连续页的申请。做实验：</p>
<p>第一步：建表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (</span><br><span class="line">    -&gt; col1 INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; col2 VARCHAR(7000),</span><br><span class="line">    -&gt; PRIMARY KEY (col1))ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
<p>上述的SQL语句创建了t1表，将col2字段设为VARCHAR(7000)，这样能保证一个页最多可以存放2条记录。此时t1.ibd大小为96KB。</p>
<p>第二步：插入两条记录，t1.ibd仍然是96KB。因为当前所有记录都在一个页中，因此没有非叶节点。</p>
<p>第三步：再插入一条记录，产生一个非叶节点。现在可以看到page offset为3的页的page level由之前的0变为了1，这时虽然新插入的记录导致了B+树的分裂操作，但这个页的类型还是B-tree Node。</p>
<p>第四步：接着继续上述同样的操作，再插入60条记录，也就是说当前表t1中共有63条记录，32个页。为了导入的方便，在这之前先建立一个导入的存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; DELIMITER//</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE PROCEDURE load_t1(count INT UNSIGNED)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE s INT UNSIGNED DEFAULT 1;</span><br><span class="line">    -&gt; DECLARE c VARCHAR(7000) DEFAULT(&apos;a&apos;,7000);</span><br><span class="line">    -&gt; WHILE s &lt;= count DO</span><br><span class="line">    -&gt; INSERT INTO t1 SELECT NULL,c;</span><br><span class="line">    -&gt; SET s = s+1;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; END;</span><br><span class="line">    -&gt; //</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER ;</span><br><span class="line"></span><br><span class="line">mysql&gt; CALL load_t1(60);</span><br></pre></td></tr></table></figure>
<p>此时t1.ibd大小为576KB。可以看到，在导入了63条数据后，表空间的大小还是小于1MB，即表示数据空间的申请还是通过碎片页，而不是通过64个连续页的区。</p>
<p>可以观察到B-tree Node页一共有33个，除去一个page level为1的非叶节点页，一共有32个page level为0的页，也就是说，对于数据段，已经有32个碎片页了。之后用户再申请空间，则表空间按连续64个页的大小开始增长了。    </p>
<p>第五步，接着就这样来操作，插入一条数据，看之后表空间的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CALL load_t1(1);</span><br></pre></td></tr></table></figure></p>
<p>此时t1.ibd大小为2.0M。因为已经用完了32个碎片页，新的页会采用区的方式进行空间的申请，如果此时用户再通过py_innodb_page_info工具来看表空间文件t1.ibd，应该可以看到很多类型为Freshly Allocated Page的页。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>同大多数数据库一样，InnoDB有页的概念，页是InnoDB磁盘管理的最小单位。在InnoDB中，默认每个页的带下为16KB。而从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。</p>
<p>在InnoDB存储引擎中，常见的页类型有： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">数据页（B-tree Node）</span><br><span class="line">undo页（undo Log Page）</span><br><span class="line">系统页（System Page）</span><br><span class="line">事务数据页（Transaction system Page）</span><br><span class="line">插入缓冲位图页（Insert Buffer Bitmap）</span><br><span class="line">插入缓冲空闲列表页（Insert Buffer Free List）</span><br><span class="line">未压缩的二进制大对象页（Uncompressed BLOB Page）</span><br><span class="line">压缩的二进制大对象页（compressed BLOB Page）</span><br></pre></td></tr></table></figure>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB是面向行的（row-oriented），也就是说数据是按行进行存放的。每个页存放的行记录也是有硬性定义的，最多允许放16KB/2 -200行的记录，即7992行记录。这里提到了row-oriented的数据库，也就是说，存在有column-oriented的数据库。MySQL infobright存储引擎就是按列来存放数据的，这对于数据仓库下的分析类SQL语句的执行及数据压缩非常有帮助。类似的数据库还有Sybase IQ、Google Big Table。</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>在MySQL 5.1版本中，默认设置为Compact行格式。用户可以通过命令SHOW TABLE STATUS LIKE ‘table_name’来查看当前表使用的行格式，其中row_format属性表示当前所使用的行记录结构类型。</p>
<h4 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h4><p>Compact行记录是在5.0中引入的，目标时为了高效地存储数据。一个也中存放的行数据越多，其性能就越高。</p>
<p>变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | …<br>Compact行记录格式的首部是一个非NULL变长字段长度列表，并且其实按照列的顺序逆序放置的，其长度为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若列的长度小于255字节，用1字节表示</span><br><span class="line">若大于255个字节，用2字节表示</span><br></pre></td></tr></table></figure>
<p>特别需要注意的是，NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际储存不不占有任何空间。</p>
<p>每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节。</p>
<p>若InnoDB表没有定义逐渐，每行还会增加一个6字节的rowid列</p>
<p>变长字段的长度最大不可以超过2字节，这是因为在MySQL数据库中VARCHAR类型的最大长度限制为65535。 <strong>（下面这个例子太清晰地解析Compact行记录格式了，后面Redundant行记录格式也用这个例子讲解得清清楚楚，赞！！！）</strong> 第一步，建表，并插入两条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE mytest (</span><br><span class="line">    -&gt; t1 VARCHAR(10),</span><br><span class="line">    -&gt; t2 VARCHAR(10),</span><br><span class="line">    -&gt; t3 CHAR(10),</span><br><span class="line">    -&gt; t4 VARCHAR(10)</span><br><span class="line">    -&gt;) ENGINE=INNODB CHARSET=LATIN1 ROW_FORMAT=COMPACT;</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO mytest</span><br><span class="line">    -&gt; VALUES (&apos;a&apos;,&apos;bb&apos;,&apos;bb&apos;,&apos;ccc&apos;);</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO mytest</span><br><span class="line">    -&gt; VALUES (&apos;d&apos;,NULL,NULL,&apos;fff&apos;);</span><br></pre></td></tr></table></figure>
<p> 第二步，查看mytest.ibd文件，转成hex看，找到第一条记录： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">03 02 01 /*变长字段长度列表，逆序*/</span><br><span class="line">00 /*NULL标志位，第一行没有NULL值*/</span><br><span class="line">00 00 10 00 2c /*Record Header,固定5字节长度*/</span><br><span class="line">00 00 00 2b 68 00 /*RowID InnoDB自动创建，6字节*/</span><br><span class="line">00 00 00 00 06 05 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">61 /*列1数据&apos;a&apos;*/</span><br><span class="line">62 62 /*列2数据&apos;bb&apos;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20 /*列3数据&apos;bb&apos;*/</span><br><span class="line">63 63 63 /*列4数据&apos;ccc&apos;*/</span><br></pre></td></tr></table></figure>
<p>需要注意的是，变长字段长度列表是逆序存放的，因此变长字段长度列表为03 02 01，而不是01 02 03。此外还需要注意InnoDB每行有隐藏列TransactionID和Roll Pointer。同时可以发现，固定长度CHAR字段在未能完全占用其长度空间时，会用0x20来进行填充。</p>
<p>接下来再分析Record Header的最后两个字节，这两个字节代表next_recorder，0x2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。所以InnoDB存储引擎在页内部是通过一种链表的结构来串连各个行记录的。 第三步，查看有NULL值得第三行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">03 01 /*变长字段长度列表，逆序*/</span><br><span class="line">06 /*NULL标志位，第三行有NULL值*/</span><br><span class="line">00 00 20 ff 98 /*Record Header*/</span><br><span class="line">00 00 00 2b 68 02 /*RowID*/</span><br><span class="line">00 00 00 00 06 07 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">64 /*列1数据&apos;d&apos;*/</span><br><span class="line">66 66 66 /*列4数据&apos;fff&apos;*/</span><br></pre></td></tr></table></figure>
<p> 第三行有NULL值，因此NULL标志位不再是00而是06，转换成二进制位00000110，为1的值代表第2列和第3列的数据为NULL。在其后存储列数据的部分，用户会发现没有存储NULL列，而只存储了第1列和第4列非NULL的值。因此这个例子很好地说明了：不管是CHAR类型还是VARCHAR类型，在compact格式下NULL值都不占用任何空间。 </p>
<h4 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h4><p>| 字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | 列3数据 | … |</p>
<p>n_fields值代表一行中列的数量，占用10位。同时这也很好地解释了为什么MySQL数据库一行支持最多的列为1023。另一个需要注意的值为1byte_offs_flags，该值定义了偏移列表占用1字节还是2字节。</p>
<p>查看一行Redundant行记录格式的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">23 20 16 14 13 0c 06 /*长度偏移列表，逆序*/</span><br><span class="line">00 00 10 0f 00 ba /*Record Header，固定6个字节*/</span><br><span class="line">00 00 00 2b 68 0b /*RowID*/</span><br><span class="line">00 00 00 00 06 53 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">61 /*列1数据&apos;a&apos;*/</span><br><span class="line">62 62 /*列2数据&apos;bb&apos;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20 /*列3数据&apos;bb&apos; Char类型*/</span><br><span class="line">63 63 63 /*列4数据 &apos;ccc&apos;*/</span><br></pre></td></tr></table></figure>
<p>23 20 16 14 13 0c 06的逆序为06，0c，13，14，16，20，23，分别代表第一列长度6，第二列长度6（6+6=0x0C），第三列长度为7（6+6+7=0x13），第四列长度为1（6+6+7+1=0x14），第五列长度2（6+6+7+1+2=0x16），第六列长度10（6+6+7+1+2+10=0x20），第七列长度3（6+6+7+1+2+10+3=0x23）。（说明第一列是从RowID开始算起的）</p>
<p>在接下来的记录头信息中应该注意48位中的第22~32位，为0000000111，表示表共有7个列（包含了隐藏的3列），接下来的第33位为1，代表偏移列表为一个字节。</p>
<p>再看一行包含NULL值得行：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">21 9e 94 14 13 0c 06 /*长度偏移列表，逆序*/</span><br><span class="line">00 00 20 0f 00 74 /*Record Header，固定6个字节*/</span><br><span class="line">00 00 00 2b 68 0d /*RowID*/</span><br><span class="line">00 00 00 00 06 53 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">64 /*列1数据&apos;d&apos;*/</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 /*列3数据NULL*/</span><br><span class="line">66 66 66 /*列4数据 &apos;fff&apos;*/</span><br></pre></td></tr></table></figure>
<p>这里与之前Compact行记录格式有着很大的不同了，首先来看长度偏移列表，逆序排列后得到06 0c 13 14 94 9e 21，前4个值都很好理解，第5个NULL值变为了94，接着第6个CHAR类型的NULL值为9e（94+10=0x9e），之后的21代表（14+3=0x21）。可以看到对于VARCHAR类型的NULL值，Redundant行记录格式同样不占用任何存储空间，而CHAR类型的NULL值需要占用空间。（虽然从文件中发现VARCHAR的NULL确实不占空间，但是为啥是94呢？94-14=80，即10000000）</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>SQL Server的VARCHAR类型最大可以存放8000字节。</p>
<p>这是因为还有别的开销，通过实际测试发现能存放VARCHAR类型的最大长度为65532。</p>
<p>需要注意的是，如果在执行上述示例的时候没有将SQL_MODE设为严格模式，或许可以建立表，但是MySQL数据库会抛出一个warning。</p>
<p>warning信息提示了这次可以创建是因为MySQL数据库自动地将VARCHAR类型转换成了TEXT类型。</p>
<p>因此从这个例子中用户也应该理解VARCHAR(N)中的N指的是字符的长度。而文档中说明VARCHAR类型最大支持65535，单位是字节。</p>
<p>此外需要注意的是，MySQL官方手册中定义的65535长度是指所有VARCHAR列的长度总和，如果列的长度总和超出这个长度，依然无法创建。</p>
<p>因此，在一般情况下，InnoDB的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompressed BLOB页中。</p>
<p>通过工具可以观察到表空间中有一个数据页节点B-tree Node，另外有4个未压缩的二进制大对象页Uncompressed BLOB Page，在这些页中才真正存放了65532字节的数据。<br>可以看到，从0x0000c093到0x0000c392数据页面其实只保存了VARCHAR（65532）的前768字节的前缀数据，之后是偏移量，指向行溢出页，也就是前面用户看到的Uncompressed BLOB Page。</p>
<p>可以这样进行思考：InnoDB存储引擎表是索引组织的，即B+Tree的结构，这样每个页中至少应该有两条行记录（否则失去了B+Tree的意义，变成链表了）。因此，如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据存放到溢出页中。（如果页中只能放下一条记录，我就不放在B+Tree里了，没意义了啊，也就是不放在表里了）<br>但是，如果可以在一个页中至少放入两行数据，那VARCHAR类型的行数据就不会存放到BLOB页中去。经过多次试验测试，发现这个阈值的长度为8098。</p>
<p>上述例子建立含有BLOB类型列的表，然后插入4行数据长度为8000的记录。若通过py_innodb_page_info工具对表空间t.ibd进行查看，会发现其实数据并没有保存在BLOB页中。（毕竟虽然类型是BLOB，可大小没超过8098嘛）</p>
<p>当然既然用户使用了BLOB列类型，一般不可能存放长度这么小的数据。因此大多数的情况下BLOB的行数据还是会发生行溢出，实际数据保存在BLOB页中，数据页只保存数据的前768字节。</p>
<h4 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h4><p>新的两种记录格式对于存放BLOB中的数据采用了完全的行溢出的方式，在数据页中只存放20个字节的指针，实际的数据都放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节。</p>
<p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>
<h4 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h4><p>从MySQL 4.1版本开始，CHAR(N)中的N指的是字符的长度，而不是之前版本的字节长度。也就是说在不同的字符集下，CHAR类型列内部存储的可能不是定长的数据。</p>
<p>因此，对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录CHAR数据类型的长度。</p>
<p>可以认为在多字节字符集的情况下，CHAR和VARCHAR实际航存储基本是没有区别的</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>其中File Header、Page Header、File Trailer的大小是固定的，分别为38、56、8字节，这些空间用来标记该页的一些信息，如Checksum，数据页所在B+树索引的层数等。User Records、Free Space、Page Directory这些部分为实际的行记录存储空间，因此大小是动态的。</p>
<h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>在InnoDB中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。</p>
<h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record就是之前讨论过的部分，即实际存储行记录的内容。再次强调，InnoDB存储引擎表总是B+树索引组织的。</p>
<p>Free Space很明显指的是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会加入到空闲链表中。</p>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>与其他数据库系统不同的是，在InnoDB中并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录（sparse directory），即一个槽中可能包含多个记录。</p>
<p>在Slots中记录按照索引键值顺序存放，这样可以利用二叉查找迅速找到记录的指针。</p>
<p>由于在InnoDB中Page Directory是稀疏目录，二叉查找的结果只是一个粗略的结果，因此InnoD必须通过recorder header中的next_record来继续查找相关记录。同时Page Directory很好地解释了recorder header中的n_owned值的含义，因为这些记录并不包括在Page Directory中。</p>
<p>需要牢记的是，B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间。</p>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>File Trailer只有一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，最后4字节和File Header中的FIL_PAGE_LSN相同。将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHECKSUM和FIL_PAGE_LSN值进行比较，看是否一致（checksum的比较需要通过InnoDB的checksum函数来进行比较，不是简单的等值比较），以此来保证页的完整性（not corrupted）。</p>
<p>MySQL 5.6.6版本开始新增了参数innodb_checksum_algorithm，该参数用来控制检测checksum函数的算法，默认值为crc32，可设置的值有：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p>
<p>启用strict_crc32方式是最快的方式，因为其不再对innodb和crc32算法进行两次检测。故推荐使用该设置。若数据库从低版本升级而来，则需要进行mysql_upgrade操作。</p>
<h4 id="InnoDB数据页结构示例分析"><a href="#InnoDB数据页结构示例分析" class="headerlink" title="InnoDB数据页结构示例分析"></a>InnoDB数据页结构示例分析</h4><p>通过Recorder Header的最后两个字节记录的下一行记录的偏移量就可以得到该页中所有的行记录，通过Page Header的PAGE_PREV和PAGE_NEXT就可以知道上个页和下个页的位置，这样InnoDB存储引擎就能读到整张表所有的行记录数据。</p>
<h3 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h3><p>InnoDB通过Named File Formats机制来解决不同版本下也结构兼容性问题。</p>
<p>Antelope文件格式有Compact和Redudant的行格式，Barracuda文件格式既包括了Antelope所有的文件格式，另外新加入了之前提到过的Compressed和Dynamic行格式。</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>实体完整性保证表中有一个主键。用户还可以通过编写一个触发器来保证数据完整性。</p>
<p>域完整性保证数据每列的值满足特定的条件。</p>
<p>域完整性可以通过一下几种途径来保证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选择合适的数据类型确保一个数据值满足特定条件</span><br><span class="line">外键约束</span><br><span class="line">编写触发器</span><br><span class="line">还可以考虑用DEFAULT约束作为强制域完整性的一个方面</span><br></pre></td></tr></table></figure></p>
<p>参照完整性保证两张表之间的关系。InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性，也可以通过编写触发器以强制执行。</p>
<h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>Foreign Key约束似乎会有一个比较神秘的默认名称。</p>
<p>在上面的例子中，通过information_schema架构下的表TABLE_CONSTRAINTS来查看当前MySQL库下所有的约束信息。对于Foreign Key的约束的命名，用户还可以通过查看表REFERENTIAL_CONSTRAINTS，并且可以详细地了解外键的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT constraint_name,constraint_type</span><br><span class="line">    -&gt; FROM information_schema.TABLE_CONSTRAINTS</span><br><span class="line">    -&gt; WHERE table_schema=&apos;mytest&apos; and table_name=&apos;p&apos;\G;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM information_schema.REFERENTIAL_CONSTRAINTS</span><br><span class="line">    -&gt; WHERE constraint_schema=&apos;mytest&apos;\G;</span><br></pre></td></tr></table></figure>
<h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>的确，当用户创建了一个唯一索引就创建了一个唯一的约束。但是约束和索引的概念还是有所不同的，约束更是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。</p>
<h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>在某些默认设置下，MySQL数据库允许非法的或不正确的数据的插入或更新，又或者可以在数据库内部将其转化为一个合法的值。</p>
<p>在上述例子中，首先向NOT NULL的列插入了一个NULL值，同时向列date插入一个非法日期’2009-02-30’。“奇怪”的是MySQL数据库并没有报错，而是显示了警告。如果用户想通过约束对于数据库非法数据的插入或更新，即MySQL数据库提示报错而不是警告，那么用户必须设置参数sql_mode，用来严格审核输入的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SET sql_mode=&apos;STRICT_TRANS_TABLES&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="ENUM和SET约束"><a href="#ENUM和SET约束" class="headerlink" title="ENUM和SET约束"></a>ENUM和SET约束</h4><p>MySQL数据库不支持传统的CHECK约束，但是通过ENUM和SET类型可以解决部分这样的约束需求。比如表中有一个性别类型，规定域的范围只可能是male或female，这时候可以用enum类型来约束</p>
<p>但是对于CHECK榆树支持的连续值的范围约束或更复杂的约束，ENUM和SET类型还是无能为力，这是用户需要通过触发器来实现对于值域的约束</p>
<h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。</p>
<p>创建触发器的命令是CREATE TRIGGER，只有具备Super权限的MySQL数据库用户才可以执行这条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE|AFTER INSERT|UPDATE|DELETE</span><br><span class="line">ON tbl_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure>
<p>目前MySQL数据库只支持FOR EACH ROE的触发方式，即按每行记录进行触发。</p>
<p>因为消费总是意味着减去一个正值，而不是负值，所以这时要通过触发器来约束这个逻辑行为，可以进行如下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE usercash_err_log (</span><br><span class="line">    -&gt; userid INT NOT NULL,</span><br><span class="line">    -&gt; old_cash INT UNSIGNED NOT NULL,</span><br><span class="line">    -&gt; new_cash INT UNSIGNED NOT NULL,</span><br><span class="line">    -&gt; user VARCHAR(30),</span><br><span class="line">    -&gt; time DATETIME);</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER $$</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TRIGGER tgr_usercash_update BEFORE UPDATE ON usercash</span><br><span class="line">    -&gt; FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; IF new.cash - old.cash &gt; 0 THEN</span><br><span class="line">    -&gt; INSERT INTO usercash_err_log</span><br><span class="line">    -&gt; SELECT old.userid,old.cash,new.cash,USER(),NOW();</span><br><span class="line">    -&gt; SET new.cash = old.cash;</span><br><span class="line">    -&gt; END IF;</span><br><span class="line">    -&gt; END;</span><br><span class="line">    -&gt; $$</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER $$</span><br></pre></td></tr></table></figure>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>外键用来保证参照完整性，MySQL数据库的M有ISAM存储引擎本身并不支持外键，对于外键的定义只是起到了一个注释的作用。而InnoDB引擎则完整支持外键约束。</p>
<p>外键的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[CONSTRAINT [symbol]] FOREIGN KEY</span><br><span class="line">[index_name] (index_col_name, ...)</span><br><span class="line">REFERENCES tbl_name (index_col_name, ...)</span><br><span class="line">[ON DELETE reference_option]</span><br><span class="line">[ON UPDATE reference_option]</span><br><span class="line">reference_option:</span><br><span class="line">RESTRICT | CASCADE | SET NULL | NO ACTION</span><br></pre></td></tr></table></figure>
<p><strong>CASCADE表示当父表发生DELETE或UPDATE操作时，对相应的子表中的数据也进行DELETE或UPDATE操作。SET NULL表示当父表发生DELETE或UPDATE操作时，相应的子表中的数据被更新为NULL值，但是子表中相对应的列必须允许为NULL值。NO ACTION表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。RESTRICT表示当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。如果定义外键时没有指定ON DELETE或ON UPDATE，RESTRICT就是默认的外键设置。</strong></p>
<p>在其他数据库中，如Oracle数据库，有一种称为延时检查（deferred check）的外键约束，即检查在SQL语句运行完成后再进行。而目前MySQL数据库的外键约束都是即时检查（immediate check），因此从上面的定义看出，在MySQL数据库中NO ACTION和RESTRICT的功能是相同的。</p>
<p>在Oracle数据库中，对于建立外键列，一定不要忘记给这个列加上一个索引。而InnoDB存储引擎在外键建立时会自动地对该列加一个索引，这和Microsoft SQL Server数据库的做法一样。因此可以很好地避免外键列上无索引而导致的死锁问题的产生。例如上述的例子中，表child创建时只定义了外键，并没有手动指定parent_id列为索引，但是通过命令SHOW CREATE TABLE可以发现InnoDB存储引擎自动为外键约束的列parent_id添加了索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SHOW CREATE TABLE child\G;</span><br><span class="line">----------------------------------</span><br><span class="line">Create Table: CREATE TABLE &apos;child&apos; (</span><br><span class="line">    &apos;id&apos; int(11) DEFAULT NULL,</span><br><span class="line">    &apos;parent_id&apos; int(11) NOT NULL,</span><br><span class="line">    KEY &apos;parent_id&apos; (&apos;parent_id&quot;),</span><br><span class="line">    CONSTRAINT &apos;child_ibfk_1&apos; FOREIGN KEY (&apos;parent_id&apos;) REFERENCES &apos;parent&apos; (&apos;id&apos;)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<p>因为MySQL数据库的外键是即时检查的，所以对导入的每一行都会进行外键检查。但是用户可以在导入过程中忽视外键的检查，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SET foreign_key_checks = 0;</span><br><span class="line">mysql&gt; LOAD DATA ......</span><br><span class="line">mysql&gt; SET foreign_key_checks = 1;</span><br></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在MySQL数据库中，视图是一个命名的虚表，它由一个SQL查询来定义，可以当作表使用。</p>
<h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><p>视图的主要用途之一是被用作一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表（base table）的结构，只需要按照视图定义来取数据或更新数据，因此视图同时在一定程度上起到一个安全层的作用。</p>
<p>创建视图的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE</span><br><span class="line">[OR REPLACE]</span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">[DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">[SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>
<p>虽然视图是基于基表的一个虚拟表，但是用户可以对某些视图进行更新操作，其本质就是通过视图的定义来更新基本表。一般称可以进行更新操作的视图为可更新视图（updatable view）。视图定义中的WITH CHECK OPTION就是针对可更新的视图的，即更新的值是否需要检查。</p>
<p>在上面的例子中，创建了一个id&lt;10的视图v_t。但之后向视图里插入了id为20的值，插入操作并没有报错。但是用户查询视图还是没能查到数据。接着更改视图的定义，加上WITH CHECK OPTION选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER VIEW v_t</span><br><span class="line">    -&gt; AS</span><br><span class="line">    -&gt; SELECT * FROM t WHERE id&lt;10</span><br><span class="line">    -&gt; WITH CHECK OPTION;</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO v_t SELECT 20;</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed &apos;mytest.v_t&apos;</span><br></pre></td></tr></table></figure>
<p>这次MySQL数据库会对更新视图插入的数据进行检查，对于不满足视图定义条件的，将会抛出一个异常，不允许视图中数据更新。</p>
<p>MySQL数据库DBA的一个常用的命令是SHOW TABLES，该命令会显示出当前数据库下所有的表。但因为视图是虚表，同样被作为表显示出来。</p>
<p>若用户只想查看当前架构下的基表，可以通过information_schema架构下的TABLE表来查询，并搜索表类型为BASE TABLE的表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM information_schema.TABLES</span><br><span class="line">    -&gt; WHERE table_type=&apos;BASE TABLE&apos;</span><br><span class="line">    -&gt; AND table_schema=database()\G;</span><br></pre></td></tr></table></figure>
<p>要想查看视图的一些元数据，可以访问information_schema架构下的VIEWS表，该表给出了视图的详细信息，包括视图定义者（definer）、定义内容、是否是可更新视图、字符集等。</p>
<h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>Oracle数据库支持物化视图——该视图不是基于基表的虚表，而是根据基表实际存在的实表，即物化视图的数据存储在非易失的存储设备上。物化视图可以用于预先计算并保存多表的链接（JOIN）或聚集（GROUP BY）等耗时较多的SQL操作结果。</p>
<p>在Microsoft SQL Server数据库中，称这种视图为索引视图。</p>
<p>查询重写是指当对无话视图的基表进行查询时，数据库会自动判断能否通过查询物化视图来直接得到最终的结果，如果可以，则避免了聚集或连接等这类较为复杂的SQL操作，直接从已经计算好的物化视图中得到所需的数据。</p>
<p>物化视图的刷新是指当基表发生了DML操作后，物化视图何时采用哪种方式和基表进行同步。ON DEMAND意味着物化视图在用户需要的时候进行刷新，ON COMMIT意味着物化视图在对基表的DML操作提交的同时进行刷新。FAST刷新采用增量刷新，只刷新自上次刷新以后进行的修改。COMPLETE刷新是对整个物化视图进行完全的刷新，如果选择FORCE方式，则数据库再刷新的时候回去判断是否可以进行快速刷新，如果可以，则采用FAST，如果不行，采用COMPLETE的方式。NEVER是指物化视图不进行任何刷新。</p>
<p>MySQL数据库本身并不支持物化视图，换句话说，MySQL数据库中的视图总是虚拟的。但是用户可以通过一些机制实现物化视图的功能。例如要创建一个ON DEMAND的物化视图还是比较简单的，用户只需定时把数据导入到另一张表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE Orders_MV(</span><br><span class="line">    -&gt; product_name VARCHAR(30) NOT NULL,</span><br><span class="line">    -&gt; price_sum DECIMAL(8,2) NOT NULL,</span><br><span class="line">    -&gt; amount_sum INT NOT NULL,</span><br><span class="line">    -&gt; price_avg FLOAT NOT NULL,</span><br><span class="line">    -&gt; orders_cut INT NOT NULL,</span><br><span class="line">    -&gt; UNIQUE INDEX (product_name));</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO Orders_MV</span><br><span class="line">    -&gt; SELECT product_name, SUM(price), SUM(amount), AVG(price), COUNT(*)</span><br><span class="line">    -&gt; FROM Orders</span><br><span class="line">    -&gt; GROUP BY product_name;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，把物化视图定义为一张表Orders_MV。如果是要实现ON DEMAND的物化视图，只需把表清空，重新导入数据即可。</p>
<p>但是，如果要实现ON COMMIT的物化视图，就不像上面这么简单了。在Oracle数据库中是通过物化视图日志来实现的，很显然在MySQL数据库没有这个日志，不过通过触发器同样可以达到这个目的，首先需要对表Orders建立一个触发器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER tgr_Orders_insert</span><br><span class="line">AFTER INSERT ON Orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    SET @old_price_sum = 0;</span><br><span class="line">    SET @old_amount_sum = 0;</span><br><span class="line">    SET @old_price_avg = 0;</span><br><span class="line">    SET @old_orders_cnt = 0;</span><br><span class="line"></span><br><span class="line">    SELECT IFNULL(price_sum,0), IFNULL(amount_sum,0), IFNULL(price_avg,0), IFNULL(orders_cnt,0)</span><br><span class="line">    FROM Orders_MV</span><br><span class="line">    WHERE product_name = NEW.product_name</span><br><span class="line">    INTO @old_price_sum, @old_amount_sum, @old_price_avg, @old_orders_cnt;</span><br><span class="line"></span><br><span class="line">    SET @new_price_sum = @old_price_sum + NEW.price;</span><br><span class="line">    SET @new_amount_sum = @old_amount_sum + NEW.amount;</span><br><span class="line">    SET @new_orders_cnt = @old_orders_cnt + 1;</span><br><span class="line">    SET @new_price_avg = @new_price_sum / @new_orders_cnt;</span><br><span class="line"></span><br><span class="line">    REPLACE INTO Orders_MV</span><br><span class="line">    VALUES(NEW.product_name, @new_price_sum, @new_amount_sum, @new_price_avg, @new_orders_cnt);</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个INSERT的触发器，每次INSERT操作都会重新统计表Orders_MV中的数据。</p>
<p>可以发现在插入两条新的记录后，直接查询Orders_MV表就能得到统计信息。而不像之前需要重新进行SQL语句的统计，这就实现了ON_COMMIT的物化视图功能。</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h4><p>分区功能并不是在存储引擎层完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持，如CSV、FEDORATED、MERGE等就不支持。</p>
<p>MySQL数据库支持的分区类型为水平分区（指将同一表中不同行的记录分配到不同的物理文件中），并不支持垂直分区。此外，MySQL数据库的分区是局部分区索引，一个分区中既存放了数据又存放了索引。而全局分区是指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。目前，MySQL数据库还不支持全局分区。</p>
<p>HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。</p>
<p>KEY分区：根据MySQL数据库提供的哈希函数来进行分区。</p>
<p>不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<p>唯一索引可以是允许NULL值得，并且分区列只要是唯一索引的一个组成部分，不需要整个唯一索引列都是分区列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (</span><br><span class="line">    -&gt; col1 INT NULL,</span><br><span class="line">    -&gt; col2 DATE NULL,</span><br><span class="line">    -&gt; col3 INT NULL,</span><br><span class="line">    -&gt; col4 INT NULL,</span><br><span class="line">    -&gt; UNIQUE KEY (col1, col2, col3, col4))</span><br><span class="line">    -&gt; PARTITION BY HASH(col3)</span><br><span class="line">    -&gt; PARTITIONS 4;</span><br></pre></td></tr></table></figure>
<p>如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列，因此下面两句创建分区的SQL语句都是可以正确运行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE t1 (</span><br><span class="line">    col1 INT NULL,</span><br><span class="line">    col2 DATE NULL,</span><br><span class="line">    col3 INT NULL,</span><br><span class="line">    col4 INT NULL,</span><br><span class="line">)engine=innodb</span><br><span class="line">PARTITION BY HASH(col3)</span><br><span class="line">PARTITIONS 4;</span><br><span class="line"></span><br><span class="line">CREATE TABLE t1 (</span><br><span class="line">    col1 INT NULL,</span><br><span class="line">    col2 DATE NULL,</span><br><span class="line">    col3 INT NULL,</span><br><span class="line">    col4 INT NULL,</span><br><span class="line">key (col4) #key不是唯一索引，所以还是可以任选一列做分区列</span><br><span class="line">)engine=innodb</span><br><span class="line">PARTITION BY HASH(col3)</span><br><span class="line">PARTITIONS 4;</span><br></pre></td></tr></table></figure>
<h4 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h4><ol>
<li><p>RANGE分区</p>
<p> 查看表在磁盘上的物理文件，启用分区之后，表不再由一个ibd文件组成了，而是由建立分区时的各个分区ibd文件组成，如下面的t#P#p0.ibd，t#P#p1.ibd。</p>
<p> 对于上述问题，我们可以对分区添加一个MAXVALUE值的分区。MAXVALUE可以理解为正无穷，因此所有大于等于20且小于MAXVALUE的值被放入p2分区。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE t</span><br><span class="line">    -&gt; ADD PARTITION(</span><br><span class="line">    -&gt; partition p2 values less than maxvalue );</span><br></pre></td></tr></table></figure>
<pre><code>RANGE分区主要用于日期列的分区，例如对于销售类的表，可以根据年来分区存放销售记录，如下面的分区表sales：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE sales(</span><br><span class="line">    -&gt; money INT UNSIGNED NOT NULL,</span><br><span class="line">    -&gt; date DATETIME</span><br><span class="line">    -&gt; )ENGINE=INNODB</span><br><span class="line">    -&gt; PARTITION by RANGE (YEAR(date)) (</span><br><span class="line">    -&gt; PARTITION p2008 VALUE LESS THAN (2009),</span><br><span class="line">    -&gt; PARTITION p2009 VALUE LESS THAN (2010),</span><br><span class="line">    -&gt; PARTITION p2010 VALUE LESS THAN (2011));</span><br></pre></td></tr></table></figure>
<p>通过EXPLAIN PARTITION命令我们可以发现，在上述语句中，SQL优化器只需要去搜索p2008这个分区，而不会去搜索所有的分区——称为Partition Pruning（分区修剪），故查询的速度得到了大幅度的提升。</p>
<p>这次条件改为date&lt;’2009-01-01’而不是date&lt;=’2008-12-31’时，优化器会选择搜索p2008和p2009两个分区，这是我们不希望看到的。因此对于启用分区，应该根据分区的特性来编写最优的SQL语句。</p>
<p>可以看到优化对分区p201001，p201002，p201003都进行了搜索。产生这个问题的主要原因是对于RANGE分区的查询，优化器只能对YEAR()，TO_DAYS()，TO_SECONDS()，UNIX_TIMESTAMP()这类函数进行优化选择，因此对于上述的要求，需要将分区函数改为TO_DAYS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE sales (</span><br><span class="line">   -&gt; money INT UNSIGNED NOT NULL,</span><br><span class="line">   -&gt; date DATETIME</span><br><span class="line">   -&gt; )ENGINE=INNODB</span><br><span class="line">   -&gt; PARTITION by range (TO_DAYS(date)) (</span><br><span class="line">   -&gt; PARTITION p201001 VALUES LESS THAN (TO_DAYS(&apos;2010-02-01&apos;)),</span><br><span class="line">   -&gt; PARTITION p201002 VALUES LESS THAN (TO_DAYS(&apos;2010-03-01&apos;)),</span><br><span class="line">   -&gt; PARTITION p201003 VALUES LESS THAN (TO_DAYS(&apos;2010-04-01&apos;))</span><br><span class="line">   -&gt; );</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>LIST分区</li>
</ol>
<p>LIST分区列的值是离散的，而非连续的</p>
<p>LIST分区使用VALUES IN，因为每个分区的值是离散的，因此只能定义值。</p>
<p>若插入的值不在分区的定义内，同样会抛出异常</p>
<p>另外，在用INSERT插入多个行数据的过程中遇到分区未定义的值时，MyISAM和InnoDB存储引擎的处理完全不同。MyISAM引擎会将之前的行数据都插入，但之后的数据不会被插入。而InnoDB存储引擎将其视为一个事务，因此没有任何数据插入。</p>
<ol start="3">
<li>HASH分区</li>
</ol>
<p>在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MySQL自动完成这些工作，用户所要做的只是基于将要进行哈希分区的列值指定一个列值或表达式，以及指定被分区的表格将要被分割成的分区数量。</p>
<p>要使用HASH分区来分割一个表，要在CREATE TABLE语句上添加一个“PARTITION BY HASH（expr）”子句，其中“expr”是一个返回一个整数的表达式。它可以仅仅是字段类型为MySQL整型的列名。</p>
<p>如果没有包括一个PARTITIONS子句，那么分区的数量将默认为1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE t_hash (</span><br><span class="line">    a INT,</span><br><span class="line">    b DATETIME</span><br><span class="line">)ENGINE=INNODB</span><br><span class="line">PARTITION BY HASH (YEAR(b))</span><br><span class="line">PARTITIONS 4;</span><br></pre></td></tr></table></figure>
<p>如果插入一个列b为2010-04-01的记录到表t_hash中，那么保存该条记录的分区如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MOD(YEAR(&apos;2010-04-01&apos;),4)</span><br><span class="line">=MOD(2010,4)</span><br><span class="line">=2</span><br></pre></td></tr></table></figure>
<p>因此记录会放入分区p2中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; SELECT table_name,partition_name,table_rows</span><br><span class="line">   -&gt; FROM information_schema.PARTITIONS</span><br><span class="line">   -&gt; WHERE table_schema=DATABASE() AND table_name=&apos;t_hash&apos;\G;</span><br></pre></td></tr></table></figure>
<p>当然这个例子中也许并不能把数据均匀地分布到各个分区中去，因为分区是按照YEAR函数进行的，而这个值本身可是离散的。如果对于连续的值进行HASH分区，如自增长的主键，则可以较好地将数据进行平均分布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE t_linear_hash(</span><br><span class="line">    a INT,</span><br><span class="line">    b DATETIME</span><br><span class="line">)ENGINE=INNODB</span><br><span class="line">PARTITION BY LINEAR HASH (YEAR(b))</span><br><span class="line">PARTITIONS 4;</span><br></pre></td></tr></table></figure>
<p>同样插入’2010-04-01’的记录，这次MySQL数据库根据以下的方法来进行分区的判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取大于分区数量4的下一个2的幂值V，V=POWER(2,CEILING(LOG(2,num)))=4；</span><br><span class="line">所在分区N=YEAR(&apos;2010-04-01&apos;)&amp;(V-1)=2。</span><br></pre></td></tr></table></figure>
<p>LINEAR HASH分区的优点在于，增加、删除、合并和拆分分区将变得更加快捷，这有利于处理含有大量数据的表。它的缺点在于，与使用HASH分区得到的数据分布相比，各个分区间数据的分布可能不大均衡。</p>
<ol start="4">
<li>KEY分区</li>
</ol>
<p>KEY分区和HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用MySQL数据库提供的函数进行区分。对于NDB Cluster引擎，MySQL数据库使用MD5函数来分区；对于其他存储引擎，MySQL数据库使用其内部的哈希函数，这些函数基于与PASSWORD()一样的运算法则。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t_key(</span><br><span class="line">    -&gt; a INT,</span><br><span class="line">    -&gt; b DATETIME)ENGINE=INNODB</span><br><span class="line">    -&gt; PARTITION BY KEY (b)</span><br><span class="line">    -&gt; PARTITIONS 4;</span><br></pre></td></tr></table></figure>
<p>在KEY分区中使用关键字LINEAR和在HASH分区中使用具有同样的效果，分区的编号是通过2的幂算法得到的，而不是通过模数算法。</p>
<ol start="5">
<li>COLUMNS分区</li>
</ol>
<p>在前面介绍的RANGE、LIST、HASH和KEY这四种分区中，分区的条件是：数据必须是整型，如果不是整型，那应该需要通过函数将其转化为整型，如YEAR()，TO_DAYS()，MONTH()等函数。</p>
<p>COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得，不需要转化为整型。此外，RANGE COLUMNS分区可以对多个列的值进行区分。</p>
<p>COLUMNS分区支持一下的数据类型： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所有的整型类型，如INT、SMALLINT、TINYINT、BIGINT。FLOAT和DECIMAL则不予支持。</span><br><span class="line">日期类型，如DATE和DATETIME。其余的日期类型不予支持。</span><br><span class="line">字符串类型，如CHAR、VARCHAR、BINARY和VARBINARY。BLOB和TEXT类型不予支持。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_columns_range(</span><br><span class="line">    a INT,</span><br><span class="line">    b DATETIME</span><br><span class="line">)ENGINE=INNODB</span><br><span class="line">PARTITION BY RANGE COLUMNS (B) (</span><br><span class="line">PARTITION p0 VALUES LESS THAN (&apos;2009-01-01&apos;),</span><br><span class="line">PARTITION p1 VALUES LESS THAN (&apos;2010-01-01&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE customers_1 (</span><br><span class="line">first_name VARCHAR(25),</span><br><span class="line">last_name VARCHAR(25),</span><br><span class="line">street_1 VARCHAR(30),</span><br><span class="line">street_2 VARCHAR(30),</span><br><span class="line">city VARCHAR(15),</span><br><span class="line">renewal DATE</span><br><span class="line">)</span><br><span class="line">PARTITION BY LIST COLUMNS(city) (</span><br><span class="line">PARTITION pRegion_1 VALUES IN (&apos;Oskarshamn&apos;, &apos;Hogsby&apos;, &apos;Monsteras&apos;),</span><br><span class="line">PARTITION pRegion_2 VALUES IN (&apos;Vimmerby&apos;, &apos;Hultsfred&apos;, &apos;Vastervik&apos;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE rcx (</span><br><span class="line">    a INT,</span><br><span class="line">    b INT,</span><br><span class="line">    c CHAR(3),</span><br><span class="line">    d INT</span><br><span class="line">)ENGINE=INNODB</span><br><span class="line">PARTITION BY RANGE COLUMNS(a,d,c) (</span><br><span class="line">PARTITIONS p0 VALUES LESS THAN (5,10,&apos;ggg&apos;),</span><br><span class="line">PARTITIONS p1 VALUES LESS THAN (10,20,&apos;mmmm&apos;),</span><br><span class="line">PARTITIONS p2 VALUES LESS THAN (15,30,&apos;sss&apos;),</span><br><span class="line">PARTITIONS p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>5.5 开始支持COLUMNS分区，对于之前的RANGE和LIST分区可以用RANGE COLUMNS和LIST COLUMNS分区很好的代替。</p>
<h4 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h4><p>子分区是在分区的基础上再进行分区，有时也称这种分区为复合分区。</p>
<p>MySQL允许在RANGE和LIST的分区上再进行HASH或KEY的子分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE ts (a INT, b DATE)ENGINE=INNODB</span><br><span class="line">    -&gt; PARTITION BY RANGE (YEAR(b))</span><br><span class="line">    -&gt; SUBPARTITION BY HASH(TO_DAYS(b))</span><br><span class="line">    -&gt; SUBPARTITIONS 2 (</span><br><span class="line">    -&gt; PARTITION p0 VALUES LESS THAN (1990),</span><br><span class="line">    -&gt; PARTITION p1 VALUES LESS THAN (2000),</span><br><span class="line">    -&gt; PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">    -&gt;);</span><br></pre></td></tr></table></figure>
<p>表ts先根据b列进行了RANGE分区，然后又进行了一次HASH分区，所以分区的数量应该为（3×2=）6个，这通过查看物理磁盘上的文件也可以得到证实。我们也可以通过使用SUBPARTITION语法来显式地指出各个子分区的名字，例如对上述的ts表同样可以这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE ts (a INT, b DATE)</span><br><span class="line">    -&gt; PARTITION BY RANGE (YEAR(b))</span><br><span class="line">    -&gt; SUBPARTITION BY HASH (TO_DAYS(b)) (</span><br><span class="line">    -&gt; PARTITION p0 VALUES LESS THAN (1990) (</span><br><span class="line">    -&gt; SUBPARTITIONS s0,</span><br><span class="line">    -&gt; SUBPARTITIONS s1</span><br><span class="line">    -&gt; ),</span><br><span class="line">    -&gt; PARTITION p1 VALUES LESS THAN (2000) (</span><br><span class="line">    -&gt; SUBPARTITION s2,</span><br><span class="line">    -&gt; SUBPARTITION s3</span><br><span class="line">    -&gt; ),</span><br><span class="line">    -&gt; PARTITION p2 VALUES LESS THAN MAXVALUE (</span><br><span class="line">    -&gt; SUBPARTITION s4,</span><br><span class="line">    -&gt; SUBPARTITION s5</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>
<p> 子分区的建立需要注意以下几个问题： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每个子分区的数量必须相同。</span><br><span class="line">要在一个分区表的任何分区上使用SUBPARTITION来明确定义任何子分区，就必须定义所有的子分区。</span><br><span class="line">每个SUBPARTITION子句必须包括子分区的一个名字。</span><br><span class="line">子分区的名字必须是唯一的。</span><br></pre></td></tr></table></figure>
<p>子分区可以用于特别大的表，在多个磁盘间分别分配数据和索引。假设有6个磁盘，分别为/disk0、/disk1、/disk2等。现在考虑下面的例子：<strong>（注意引擎是MyISAM！）</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE ts (a INT, b DATE)ENGINE=MYISAM</span><br><span class="line">    -&gt; PARTITION BY RANGE (YEAR(b))</span><br><span class="line">    -&gt; SUBPARTITION BY HASH (TO_DAYS(b)) (</span><br><span class="line">    -&gt; PARTITION p0 VALUES LESS THAN (1990) (</span><br><span class="line">    -&gt; SUBPARTITIONS s0</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk0/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk0/idx&apos;,</span><br><span class="line">    -&gt; SUBPARTITIONS s1</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk1/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk1/idx&apos;</span><br><span class="line">    -&gt; ),</span><br><span class="line">    -&gt; PARTITION p1 VALUES LESS THAN (2000) (</span><br><span class="line">    -&gt; SUBPARTITION s2</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk2/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk2/idx&apos;,</span><br><span class="line">    -&gt; SUBPARTITION s3</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk3/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk3/idx&apos;</span><br><span class="line">    -&gt; ),</span><br><span class="line">    -&gt; PARTITION p2 VALUES LESS THAN MAXVALUE (</span><br><span class="line">    -&gt; SUBPARTITION s4</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk4/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk4/idx&apos;,</span><br><span class="line">    -&gt; SUBPARTITION s5</span><br><span class="line">    -&gt; DATA DIRECTORY = &apos;/disk5/data&apos;</span><br><span class="line">    -&gt; INDEX DIRECTORY = &apos;/disk5/idx&apos;</span><br><span class="line">    -&gt; )</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>
<p><strong>由于InnoDB存储引擎使用表空间自动地进行数据和索引的管理，因此会忽略DATA DIRECTORY和INDEX DIRECTORY语法，因此上述的分区表的数据和索引文件分开放置对其是无效的。</strong> </p>
<h4 id="分区中的NULL值"><a href="#分区中的NULL值" class="headerlink" title="分区中的NULL值"></a>分区中的NULL值</h4><p>MySQL数据库的分区总是视NULL值小于任何的一个非NULL值，这和MySQL数据库中处理NULL值得ORDER BY操作是一样的。</p>
<p>对于RANGE分区，如果向分区列插入了NULL值，则MySQL数据库会将该值放入最左边的分区。</p>
<p>另外需要注意的是，如果删除p0这个分区，删除的将是小于10的记录，并且还有NULL值得记录，这点非常重要。</p>
<p>在LIST分区下要使用NULL值，则必须显式地指出哪个分区中放入NULL值，否则会报错。</p>
<p>HASH和KEY分区对于NULL的处理方式和RANGE分区、LIST分区不一样。任何分区函数都会将含有NULL值得记录返回为0。</p>
<h4 id="分区和性能"><a href="#分区和性能" class="headerlink" title="分区和性能"></a>分区和性能</h4><p>数据库的应用分为两类：一类是OLTP（在线事务处理），如Blog、电子商务、网络游戏等；另一类是OLAP（在线分析处理），如数据仓库、数据集市。在一个实际的应用环境中，可能既有OLTP的应用，也有OLAP的应用。如网络游戏中，玩家操作的游戏数据库应用就是OLTP的，但是游戏厂商可能需要对游戏产生的日志进行分析，通过分析得到的结果来更好地服务于游戏，预测玩家的行为等，而这却是OLAP的应用。</p>
<p>对于OLAP的应用，分区的确是可以很好地提高查询的性能，因为OLAP应用大多数查询需要频繁地扫描一张很大的表。假设有一张一亿行的表，其中有一个时间戳属性列。用户的查询需要从这张表中获取一年的数据。如果按时间戳进行分区，则只需要扫描相应的分区即可。这就是前面介绍的Partition Pruning技术。</p>
<p>然而对于OLTP的应用，分区应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，一般的B+树需要2~3次的磁盘IO。因此B+树可以很好地完成操作，不需要分区的帮助，并且设计不好的分区会带来严重的性能问题。</p>
<p>但是有没有考虑过这样一种情况：100W和1000W行的数据本身构成的B+树的层次都是一样的，可能都是2层。那么上述走主键分区的索引并不会带来性能的提高。好的，如果1000W的B+树的高度是3，100W的B+树的高度是2，那么上述按主键分区的索引可以避免1次IO，从而提高查询效率。这没问题，但是这张表只有主键索引，没有任何其他的列需要查询的。如果还有类似如下的SQL语句：SELECT * FROM TABLE WHERE KEY = @key，这时对于KEY的查询需要扫描所有的10个分区，即使每个分区的查询开销为2次IO，则一共需要20次IO。而对于原来单表的设计，对于KEY的查询只需要2~3次IO。</p>
<p>即使是根据自增长主键进行的HASH分区也不能保证分区数据的均匀。因为插入的自增长ID并非总是连续的，如果该主键值因为某种原因被回滚了，则该值将不会再次被自动使用。</p>
<p>如果进行主键的查询，可以发现分区的确是有意义的。可以发现指寻找了p1分区，但是对于表Profile中nickname列索引的查询，EXPLAIN PARTITIONS则会得到如下结果。可以看到，MySQL数据库会搜索所有的分区，因此查询速度会慢很多。</p>
<p>上述简单的索引查找语句竟然需要1.05秒，这显然是因为查询需要遍历所有分区的关系，实际的IO执行了约20~30次。而在未分区的同样结构和大小的表上，执行上述同样的SQL语句只需要0.26秒。</p>
<p>因此对于使用InnoDB存储引擎作为OLTP应用的表在使用分区时应该十分小心，设计时确认数据的访问模式，否在在OLTP应用下分区可能不仅不会带来查询速度的提高，反而可能会使你的应用执行得更慢。</p>
<h4 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h4><p>MySQL 5.6开始支持ALTER TABLE … EXCHANGE PARTITION语法。该语句允许分区或子分区中的数据与另一个非分区的表中的数据进行交换。</p>
<p>要交换的表需和分区表有着相同的表结构，但是表不能还有分区。</p>
<p>在非分区表中的数据必须在交换的分区定义内。</p>
<p>被交换的表中不能含有外键，或者其他的表含有对该表的外键引用</p>
<p>用户除了需要ALTER、INSERT和CREATE权限外，还需要DROP的权限</p>
<p>使用该语句时，不会触发交换表和被交换表上的触发器</p>
<p>AUTO_INCREMENT列将被重置。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE e (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30)</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (id) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (50),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (100),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (150),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN (MAXVALUE)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO e VALUES</span><br><span class="line">(1669, &quot;Jim&quot;, &quot;Smith&quot;),</span><br><span class="line">(337, &quot;Mary&quot;, &quot;Jones&quot;),</span><br><span class="line">(16, &quot;Frank&quot;, &quot;White&quot;),</span><br><span class="line">(2005, &quot;Linda&quot;, &quot;Black&quot;);</span><br></pre></td></tr></table></figure>
<p>然后创建交换表e2。表e2的结构和表e一样，但需要注意的是表e2不能含有分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE e2 LIKE e;</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE e2 REMOVE PARTITIONING;</span><br></pre></td></tr></table></figure>
<p>因为表e2中没有数据，使用如下语句将表e的分区p0中的数据移动到表e2中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</span><br></pre></td></tr></table></figure>
<p>这时再观察表e中分区的数据，可以发现p0中的数据已经没有了。而这时可以在表e2中观察到被移动的数据。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/19/MySQL常见的两种存储引擎/" rel="next" title="MySQL常见的两种存储引擎">
                <i class="fa fa-chevron-left"></i> MySQL常见的两种存储引擎
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/23/Mysql技术内幕/第5章 索引与算法/" rel="prev" title="第5章 索引与算法">
                第5章 索引与算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/quan.jpg" alt="孙九博">
            
              <p class="site-author-name" itemprop="name">孙九博</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#弟4章-表"><span class="nav-number">1.</span> <span class="nav-text">弟4章 表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引组织表"><span class="nav-number">1.1.</span> <span class="nav-text">索引组织表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB逻辑存储结构"><span class="nav-number">1.2.</span> <span class="nav-text">InnoDB逻辑存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#表空间"><span class="nav-number">1.2.1.</span> <span class="nav-text">表空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段"><span class="nav-number">1.2.2.</span> <span class="nav-text">段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区"><span class="nav-number">1.2.3.</span> <span class="nav-text">区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页"><span class="nav-number">1.2.4.</span> <span class="nav-text">页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行"><span class="nav-number">1.2.5.</span> <span class="nav-text">行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB行记录格式"><span class="nav-number">1.3.</span> <span class="nav-text">InnoDB行记录格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compact行记录格式"><span class="nav-number">1.3.1.</span> <span class="nav-text">Compact行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redundant行记录格式"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redundant行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行溢出数据"><span class="nav-number">1.3.3.</span> <span class="nav-text">行溢出数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compressed和Dynamic行记录格式"><span class="nav-number">1.3.4.</span> <span class="nav-text">Compressed和Dynamic行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CHAR的行结构存储"><span class="nav-number">1.3.5.</span> <span class="nav-text">CHAR的行结构存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB数据页结构"><span class="nav-number">1.4.</span> <span class="nav-text">InnoDB数据页结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Header"><span class="nav-number">1.4.1.</span> <span class="nav-text">File Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#User-Record和Free-Space"><span class="nav-number">1.4.2.</span> <span class="nav-text">User Record和Free Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page-Directory"><span class="nav-number">1.4.3.</span> <span class="nav-text">Page Directory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Trailer"><span class="nav-number">1.4.4.</span> <span class="nav-text">File Trailer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB数据页结构示例分析"><span class="nav-number">1.4.5.</span> <span class="nav-text">InnoDB数据页结构示例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Named-File-Formats机制"><span class="nav-number">1.5.</span> <span class="nav-text">Named File Formats机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束"><span class="nav-number">1.6.</span> <span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据完整性"><span class="nav-number">1.6.1.</span> <span class="nav-text">数据完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#约束的创建和查找"><span class="nav-number">1.6.2.</span> <span class="nav-text">约束的创建和查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#约束和索引的区别"><span class="nav-number">1.6.3.</span> <span class="nav-text">约束和索引的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对错误数据的约束"><span class="nav-number">1.6.4.</span> <span class="nav-text">对错误数据的约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENUM和SET约束"><span class="nav-number">1.6.5.</span> <span class="nav-text">ENUM和SET约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触发器与约束"><span class="nav-number">1.6.6.</span> <span class="nav-text">触发器与约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外键约束"><span class="nav-number">1.6.7.</span> <span class="nav-text">外键约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">1.7.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#视图的作用"><span class="nav-number">1.7.1.</span> <span class="nav-text">视图的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物化视图"><span class="nav-number">1.7.2.</span> <span class="nav-text">物化视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区表"><span class="nav-number">1.8.</span> <span class="nav-text">分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分区概述"><span class="nav-number">1.8.1.</span> <span class="nav-text">分区概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区类型"><span class="nav-number">1.8.2.</span> <span class="nav-text">分区类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子分区"><span class="nav-number">1.8.3.</span> <span class="nav-text">子分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区中的NULL值"><span class="nav-number">1.8.4.</span> <span class="nav-text">分区中的NULL值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区和性能"><span class="nav-number">1.8.5.</span> <span class="nav-text">分区和性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在表和分区间交换数据"><span class="nav-number">1.8.6.</span> <span class="nav-text">在表和分区间交换数据</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙九博</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
