<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">
<meta property="og:type" content="article">
<meta property="og:title" content="弟4章 表">
<meta property="og:url" content="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/index.html">
<meta property="og:site_name" content="NineBoy&#39;s Blog">
<meta property="og:description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-21T14:03:48.873Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="弟4章 表">
<meta name="twitter:description" content="弟4章 表索引组织表在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/">





  <title>弟4章 表 | NineBoy's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NineBoy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://SunJiubo.github.io/2019/04/19/Mysql技术内幕/第4章 表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="孙九博">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/quan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NineBoy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">弟4章 表</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-19T20:10:15+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="弟4章-表"><a href="#弟4章-表" class="headerlink" title="弟4章 表"></a>弟4章 表</h2><h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table）。在InnoDB表中，每张表都有个主键，如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。</span><br><span class="line">如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。</span><br></pre></td></tr></table></figure></p>
<p><strong>当表中有多个非空唯一索引时，InnoDB将选择建表时第一个定义的非空唯一索引为主键。这里需要注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE z (</span><br><span class="line">    -&gt; a INT NOT NULL,</span><br><span class="line">    -&gt; b INT NULL,</span><br><span class="line">    -&gt; c INT NOT NULL,</span><br><span class="line">    -&gt; d INT NOT NULL,</span><br><span class="line">    -&gt; UNIQUE KEY (b),</span><br><span class="line">    -&gt; UNIQUE KEY (d), UNIQUE KEY (c)); # d是主键，b不是非空的，a不是唯一的，d排在c前边</span><br></pre></td></tr></table></figure>
<p>因为d列首先定义为一个唯一索引，故InnoDB将其视为主键。</p>
<p>_rowid可以显示表的主键，因此通过上述查询可以找到表z的主键。 另外需要注意的是，_rowid只能用于查看单个列为主键的情况，对于多列组成的键就显得无能为力了。 </p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也成为块（block）。</p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>如果启用了innodb_file_per_table的参数，每张表内的数据可以单独放到一个表空间，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息、二次写缓冲（Double write buffer）等还是存放在原来的共享表空间中。</p>
<p>接着执行会产生大量undo操作的语句update mytest set salary=0，完成后再观察共享表空间，会发现ibdata1已经增长到了114MB。（有更新操作，自然就要记录undo信息）这个例子虽然简单，但是足以说明共享表空间中还包含有undo信息。</p>
<p>很“可惜”，共享表空间的大小还是114MB，即InnoDB不会再执行rollback时去收缩这个表空间。虽然InnoDB不会回收这些空间，但是会自动判断这些undo信息是否还需要，如果不需要，则会将这些空间标记为可用空间，供下次undo使用。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。因为前面已经介绍过了InnoDB表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点（Leaf node segment），索引段即为B+树的非索引节点（Non-leaf node segment）。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB一次从磁盘申请4~5个区。在默认情况下，InnoDB页的大小为16KB，即一个区中一共有64个连续的页。无论页的大小怎么变化，区的大小总是1M。</p>
<p>但是，这里还有一个问题：在用户启用了参数innodb_file_per_table后，创建的表默认大小是96KB。区中是64个连续的页，创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先用32个页大小的碎片页（fragment page）来存放数据，在使用完这些页之后才是64个连续页的申请。做实验：</p>
<p>第一步：建表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE t1 (</span><br><span class="line">    -&gt; col1 INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; col2 VARCHAR(7000),</span><br><span class="line">    -&gt; PRIMARY KEY (col1))ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
<p>上述的SQL语句创建了t1表，将col2字段设为VARCHAR(7000)，这样能保证一个页最多可以存放2条记录。此时t1.ibd大小为96KB。</p>
<p>第二步：插入两条记录，t1.ibd仍然是96KB。因为当前所有记录都在一个页中，因此没有非叶节点。</p>
<p>第三步：再插入一条记录，产生一个非叶节点。现在可以看到page offset为3的页的page level由之前的0变为了1，这时虽然新插入的记录导致了B+树的分裂操作，但这个页的类型还是B-tree Node。</p>
<p>第四步：接着继续上述同样的操作，再插入60条记录，也就是说当前表t1中共有63条记录，32个页。为了导入的方便，在这之前先建立一个导入的存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; DELIMITER//</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE PROCEDURE load_t1(count INT UNSIGNED)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE s INT UNSIGNED DEFAULT 1;</span><br><span class="line">    -&gt; DECLARE c VARCHAR(7000) DEFAULT(&apos;a&apos;,7000);</span><br><span class="line">    -&gt; WHILE s &lt;= count DO</span><br><span class="line">    -&gt; INSERT INTO t1 SELECT NULL,c;</span><br><span class="line">    -&gt; SET s = s+1;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; END;</span><br><span class="line">    -&gt; //</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER ;</span><br><span class="line"></span><br><span class="line">mysql&gt; CALL load_t1(60);</span><br></pre></td></tr></table></figure>
<p>此时t1.ibd大小为576KB。可以看到，在导入了63条数据后，表空间的大小还是小于1MB，即表示数据空间的申请还是通过碎片页，而不是通过64个连续页的区。</p>
<p>可以观察到B-tree Node页一共有33个，除去一个page level为1的非叶节点页，一共有32个page level为0的页，也就是说，对于数据段，已经有32个碎片页了。之后用户再申请空间，则表空间按连续64个页的大小开始增长了。    </p>
<p>第五步，接着就这样来操作，插入一条数据，看之后表空间的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CALL load_t1(1);</span><br></pre></td></tr></table></figure></p>
<p>此时t1.ibd大小为2.0M。因为已经用完了32个碎片页，新的页会采用区的方式进行空间的申请，如果此时用户再通过py_innodb_page_info工具来看表空间文件t1.ibd，应该可以看到很多类型为Freshly Allocated Page的页。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>同大多数数据库一样，InnoDB有页的概念，页是InnoDB磁盘管理的最小单位。在InnoDB中，默认每个页的带下为16KB。而从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以对其再次进行修改。除非通过mysqldump导入和导出操作来产生新的库。</p>
<p>在InnoDB存储引擎中，常见的页类型有： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">数据页（B-tree Node）</span><br><span class="line">undo页（undo Log Page）</span><br><span class="line">系统页（System Page）</span><br><span class="line">事务数据页（Transaction system Page）</span><br><span class="line">插入缓冲位图页（Insert Buffer Bitmap）</span><br><span class="line">插入缓冲空闲列表页（Insert Buffer Free List）</span><br><span class="line">未压缩的二进制大对象页（Uncompressed BLOB Page）</span><br><span class="line">压缩的二进制大对象页（compressed BLOB Page）</span><br></pre></td></tr></table></figure>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB是面向行的（row-oriented），也就是说数据是按行进行存放的。每个页存放的行记录也是有硬性定义的，最多允许放16KB/2 -200行的记录，即7992行记录。这里提到了row-oriented的数据库，也就是说，存在有column-oriented的数据库。MySQL infobright存储引擎就是按列来存放数据的，这对于数据仓库下的分析类SQL语句的执行及数据压缩非常有帮助。类似的数据库还有Sybase IQ、Google Big Table。</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>在MySQL 5.1版本中，默认设置为Compact行格式。用户可以通过命令SHOW TABLE STATUS LIKE ‘table_name’来查看当前表使用的行格式，其中row_format属性表示当前所使用的行记录结构类型。</p>
<h4 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h4><p>Compact行记录是在5.0中引入的，目标时为了高效地存储数据。一个也中存放的行数据越多，其性能就越高。</p>
<p>变长字段长度列表 | NULL标志位 | 记录头信息 | 列1数据 | 列2数据 | …<br>Compact行记录格式的首部是一个非NULL变长字段长度列表，并且其实按照列的顺序逆序放置的，其长度为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若列的长度小于255字节，用1字节表示</span><br><span class="line">若大于255个字节，用2字节表示</span><br></pre></td></tr></table></figure>
<p>特别需要注意的是，NULL不占该部分任何空间，即NULL除了占有NULL标志位，实际储存不不占有任何空间。</p>
<p>每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节。</p>
<p>若InnoDB表没有定义逐渐，每行还会增加一个6字节的rowid列</p>
<p>变长字段的长度最大不可以超过2字节，这是因为在MySQL数据库中VARCHAR类型的最大长度限制为65535。 <strong>（下面这个例子太清晰地解析Compact行记录格式了，后面Redundant行记录格式也用这个例子讲解得清清楚楚，赞！！！）</strong> 第一步，建表，并插入两条记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE mytest (</span><br><span class="line">    -&gt; t1 VARCHAR(10),</span><br><span class="line">    -&gt; t2 VARCHAR(10),</span><br><span class="line">    -&gt; t3 CHAR(10),</span><br><span class="line">    -&gt; t4 VARCHAR(10)</span><br><span class="line">    -&gt;) ENGINE=INNODB CHARSET=LATIN1 ROW_FORMAT=COMPACT;</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO mytest</span><br><span class="line">    -&gt; VALUES (&apos;a&apos;,&apos;bb&apos;,&apos;bb&apos;,&apos;ccc&apos;);</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO mytest</span><br><span class="line">    -&gt; VALUES (&apos;d&apos;,NULL,NULL,&apos;fff&apos;);</span><br></pre></td></tr></table></figure>
<p> 第二步，查看mytest.ibd文件，转成hex看，找到第一条记录： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">03 02 01 /*变长字段长度列表，逆序*/</span><br><span class="line">00 /*NULL标志位，第一行没有NULL值*/</span><br><span class="line">00 00 10 00 2c /*Record Header,固定5字节长度*/</span><br><span class="line">00 00 00 2b 68 00 /*RowID InnoDB自动创建，6字节*/</span><br><span class="line">00 00 00 00 06 05 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">61 /*列1数据&apos;a&apos;*/</span><br><span class="line">62 62 /*列2数据&apos;bb&apos;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20 /*列3数据&apos;bb&apos;*/</span><br><span class="line">63 63 63 /*列4数据&apos;ccc&apos;*/</span><br></pre></td></tr></table></figure>
<p>需要注意的是，变长字段长度列表是逆序存放的，因此变长字段长度列表为03 02 01，而不是01 02 03。此外还需要注意InnoDB每行有隐藏列TransactionID和Roll Pointer。同时可以发现，固定长度CHAR字段在未能完全占用其长度空间时，会用0x20来进行填充。</p>
<p>接下来再分析Record Header的最后两个字节，这两个字节代表next_recorder，0x2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。所以InnoDB存储引擎在页内部是通过一种链表的结构来串连各个行记录的。 第三步，查看有NULL值得第三行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">03 01 /*变长字段长度列表，逆序*/</span><br><span class="line">06 /*NULL标志位，第三行有NULL值*/</span><br><span class="line">00 00 20 ff 98 /*Record Header*/</span><br><span class="line">00 00 00 2b 68 02 /*RowID*/</span><br><span class="line">00 00 00 00 06 07 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">64 /*列1数据&apos;d&apos;*/</span><br><span class="line">66 66 66 /*列4数据&apos;fff&apos;*/</span><br></pre></td></tr></table></figure>
<p> 第三行有NULL值，因此NULL标志位不再是00而是06，转换成二进制位00000110，为1的值代表第2列和第3列的数据为NULL。在其后存储列数据的部分，用户会发现没有存储NULL列，而只存储了第1列和第4列非NULL的值。因此这个例子很好地说明了：不管是CHAR类型还是VARCHAR类型，在compact格式下NULL值都不占用任何空间。 </p>
<h4 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h4><p>| 字段长度偏移列表 | 记录头信息 | 列1数据 | 列2数据 | 列3数据 | … |</p>
<p>n_fields值代表一行中列的数量，占用10位。同时这也很好地解释了为什么MySQL数据库一行支持最多的列为1023。另一个需要注意的值为1byte_offs_flags，该值定义了偏移列表占用1字节还是2字节。</p>
<p>查看一行Redundant行记录格式的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">23 20 16 14 13 0c 06 /*长度偏移列表，逆序*/</span><br><span class="line">00 00 10 0f 00 ba /*Record Header，固定6个字节*/</span><br><span class="line">00 00 00 2b 68 0b /*RowID*/</span><br><span class="line">00 00 00 00 06 53 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">61 /*列1数据&apos;a&apos;*/</span><br><span class="line">62 62 /*列2数据&apos;bb&apos;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20 /*列3数据&apos;bb&apos; Char类型*/</span><br><span class="line">63 63 63 /*列4数据 &apos;ccc&apos;*/</span><br></pre></td></tr></table></figure>
<p>23 20 16 14 13 0c 06的逆序为06，0c，13，14，16，20，23，分别代表第一列长度6，第二列长度6（6+6=0x0C），第三列长度为7（6+6+7=0x13），第四列长度为1（6+6+7+1=0x14），第五列长度2（6+6+7+1+2=0x16），第六列长度10（6+6+7+1+2+10=0x20），第七列长度3（6+6+7+1+2+10+3=0x23）。（说明第一列是从RowID开始算起的）</p>
<p>在接下来的记录头信息中应该注意48位中的第22~32位，为0000000111，表示表共有7个列（包含了隐藏的3列），接下来的第33位为1，代表偏移列表为一个字节。</p>
<p>再看一行包含NULL值得行：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">21 9e 94 14 13 0c 06 /*长度偏移列表，逆序*/</span><br><span class="line">00 00 20 0f 00 74 /*Record Header，固定6个字节*/</span><br><span class="line">00 00 00 2b 68 0d /*RowID*/</span><br><span class="line">00 00 00 00 06 53 /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10 /*Roll Pointer*/</span><br><span class="line">64 /*列1数据&apos;d&apos;*/</span><br><span class="line">00 00 00 00 00 00 00 00 00 00 /*列3数据NULL*/</span><br><span class="line">66 66 66 /*列4数据 &apos;fff&apos;*/</span><br></pre></td></tr></table></figure>
<p>这里与之前Compact行记录格式有着很大的不同了，首先来看长度偏移列表，逆序排列后得到06 0c 13 14 94 9e 21，前4个值都很好理解，第5个NULL值变为了94，接着第6个CHAR类型的NULL值为9e（94+10=0x9e），之后的21代表（14+3=0x21）。可以看到对于VARCHAR类型的NULL值，Redundant行记录格式同样不占用任何存储空间，而CHAR类型的NULL值需要占用空间。（虽然从文件中发现VARCHAR的NULL确实不占空间，但是为啥是94呢？94-14=80，即10000000）</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>SQL Server的VARCHAR类型最大可以存放8000字节。</p>
<p>这是因为还有别的开销，通过实际测试发现能存放VARCHAR类型的最大长度为65532。</p>
<p>需要注意的是，如果在执行上述示例的时候没有将SQL_MODE设为严格模式，或许可以建立表，但是MySQL数据库会抛出一个warning。</p>
<p>warning信息提示了这次可以创建是因为MySQL数据库自动地将VARCHAR类型转换成了TEXT类型。</p>
<p>因此从这个例子中用户也应该理解VARCHAR(N)中的N指的是字符的长度。而文档中说明VARCHAR类型最大支持65535，单位是字节。</p>
<p>此外需要注意的是，MySQL官方手册中定义的65535长度是指所有VARCHAR列的长度总和，如果列的长度总和超出这个长度，依然无法创建。</p>
<p>因此，在一般情况下，InnoDB的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompressed BLOB页中。</p>
<p>通过工具可以观察到表空间中有一个数据页节点B-tree Node，另外有4个未压缩的二进制大对象页Uncompressed BLOB Page，在这些页中才真正存放了65532字节的数据。<br>可以看到，从0x0000c093到0x0000c392数据页面其实只保存了VARCHAR（65532）的前768字节的前缀数据，之后是偏移量，指向行溢出页，也就是前面用户看到的Uncompressed BLOB Page。</p>
<p>可以这样进行思考：InnoDB存储引擎表是索引组织的，即B+Tree的结构，这样每个页中至少应该有两条行记录（否则失去了B+Tree的意义，变成链表了）。因此，如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据存放到溢出页中。（如果页中只能放下一条记录，我就不放在B+Tree里了，没意义了啊，也就是不放在表里了）<br>但是，如果可以在一个页中至少放入两行数据，那VARCHAR类型的行数据就不会存放到BLOB页中去。经过多次试验测试，发现这个阈值的长度为8098。</p>
<p>上述例子建立含有BLOB类型列的表，然后插入4行数据长度为8000的记录。若通过py_innodb_page_info工具对表空间t.ibd进行查看，会发现其实数据并没有保存在BLOB页中。（毕竟虽然类型是BLOB，可大小没超过8098嘛）</p>
<p>当然既然用户使用了BLOB列类型，一般不可能存放长度这么小的数据。因此大多数的情况下BLOB的行数据还是会发生行溢出，实际数据保存在BLOB页中，数据页只保存数据的前768字节。</p>
<h4 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h4><p>新的两种记录格式对于存放BLOB中的数据采用了完全的行溢出的方式，在数据页中只存放20个字节的指针，实际的数据都放在Off Page中，而之前的Compact和Redundant两种格式会存放768个前缀字节。</p>
<p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>
<h4 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h4><p>从MySQL 4.1版本开始，CHAR(N)中的N指的是字符的长度，而不是之前版本的字节长度。也就是说在不同的字符集下，CHAR类型列内部存储的可能不是定长的数据。</p>
<p>因此，对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型。这也就意味着在变长长度列表中会记录CHAR数据类型的长度。</p>
<p>可以认为在多字节字符集的情况下，CHAR和VARCHAR实际航存储基本是没有区别的</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>其中File Header、Page Header、File Trailer的大小是固定的，分别为38、56、8字节，这些空间用来标记该页的一些信息，如Checksum，数据页所在B+树索引的层数等。User Records、Free Space、Page Directory这些部分为实际的行记录存储空间，因此大小是动态的。</p>
<h4 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h4><p>在InnoDB中，每个数据页中有两个虚拟的行记录，用来限定记录的边界。Infimum记录是比该页中任何主键值都要小的值，Supremum指比任何可能大的值还要大的值。这两个值在页创建时被建立，并且在任何情况下不会被删除。</p>
<h4 id="User-Record和Free-Space"><a href="#User-Record和Free-Space" class="headerlink" title="User Record和Free Space"></a>User Record和Free Space</h4><p>User Record就是之前讨论过的部分，即实际存储行记录的内容。再次强调，InnoDB存储引擎表总是B+树索引组织的。</p>
<p>Free Space很明显指的是空闲空间，同样也是个链表数据结构。在一条记录被删除后，该空间会加入到空闲链表中。</p>
<h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>与其他数据库系统不同的是，在InnoDB中并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录（sparse directory），即一个槽中可能包含多个记录。</p>
<p>在Slots中记录按照索引键值顺序存放，这样可以利用二叉查找迅速找到记录的指针。</p>
<p>由于在InnoDB中Page Directory是稀疏目录，二叉查找的结果只是一个粗略的结果，因此InnoD必须通过recorder header中的next_record来继续查找相关记录。同时Page Directory很好地解释了recorder header中的n_owned值的含义，因为这些记录并不包括在Page Directory中。</p>
<p>需要牢记的是，B+树索引本身并不能找到具体的一条记录，能找到只是该记录所在的页。数据库把页载入内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度很低，同时在内存中的查找很快，因此通常忽略这部分查找所用的时间。</p>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h4><p>File Trailer只有一个FIL_PAGE_END_LSN部分，占用8字节。前4字节代表该页的checksum值，最后4字节和File Header中的FIL_PAGE_LSN相同。将这两个值与File Header中的FIL_PAGE_SPACE_OR_CHECKSUM和FIL_PAGE_LSN值进行比较，看是否一致（checksum的比较需要通过InnoDB的checksum函数来进行比较，不是简单的等值比较），以此来保证页的完整性（not corrupted）。</p>
<p>MySQL 5.6.6版本开始新增了参数innodb_checksum_algorithm，该参数用来控制检测checksum函数的算法，默认值为crc32，可设置的值有：innodb、crc32、none、strict_innodb、strict_crc32、strict_none。</p>
<p>启用strict_crc32方式是最快的方式，因为其不再对innodb和crc32算法进行两次检测。故推荐使用该设置。若数据库从低版本升级而来，则需要进行mysql_upgrade操作。</p>
<h4 id="InnoDB数据页结构示例分析"><a href="#InnoDB数据页结构示例分析" class="headerlink" title="InnoDB数据页结构示例分析"></a>InnoDB数据页结构示例分析</h4><p>通过Recorder Header的最后两个字节记录的下一行记录的偏移量就可以得到该页中所有的行记录，通过Page Header的PAGE_PREV和PAGE_NEXT就可以知道上个页和下个页的位置，这样InnoDB存储引擎就能读到整张表所有的行记录数据。</p>
<h3 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h3><p>InnoDB通过Named File Formats机制来解决不同版本下也结构兼容性问题。</p>
<p>Antelope文件格式有Compact和Redudant的行格式，Barracuda文件格式既包括了Antelope所有的文件格式，另外新加入了之前提到过的Compressed和Dynamic行格式。</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>实体完整性保证表中有一个主键。用户还可以通过编写一个触发器来保证数据完整性。</p>
<p>域完整性保证数据每列的值满足特定的条件。</p>
<p>域完整性可以通过一下几种途径来保证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">选择合适的数据类型确保一个数据值满足特定条件</span><br><span class="line">外键约束</span><br><span class="line">编写触发器</span><br><span class="line">还可以考虑用DEFAULT约束作为强制域完整性的一个方面</span><br></pre></td></tr></table></figure></p>
<p>参照完整性保证两张表之间的关系。InnoDB存储引擎支持外键，因此允许用户定义外键以强制参照完整性，也可以通过编写触发器以强制执行。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/19/MySQL常见的两种存储引擎/" rel="next" title="MySQL常见的两种存储引擎">
                <i class="fa fa-chevron-left"></i> MySQL常见的两种存储引擎
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/quan.jpg" alt="孙九博">
            
              <p class="site-author-name" itemprop="name">孙九博</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#弟4章-表"><span class="nav-number">1.</span> <span class="nav-text">弟4章 表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引组织表"><span class="nav-number">1.1.</span> <span class="nav-text">索引组织表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB逻辑存储结构"><span class="nav-number">1.2.</span> <span class="nav-text">InnoDB逻辑存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#表空间"><span class="nav-number">1.2.1.</span> <span class="nav-text">表空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段"><span class="nav-number">1.2.2.</span> <span class="nav-text">段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区"><span class="nav-number">1.2.3.</span> <span class="nav-text">区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页"><span class="nav-number">1.2.4.</span> <span class="nav-text">页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行"><span class="nav-number">1.2.5.</span> <span class="nav-text">行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB行记录格式"><span class="nav-number">1.3.</span> <span class="nav-text">InnoDB行记录格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compact行记录格式"><span class="nav-number">1.3.1.</span> <span class="nav-text">Compact行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redundant行记录格式"><span class="nav-number">1.3.2.</span> <span class="nav-text">Redundant行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行溢出数据"><span class="nav-number">1.3.3.</span> <span class="nav-text">行溢出数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compressed和Dynamic行记录格式"><span class="nav-number">1.3.4.</span> <span class="nav-text">Compressed和Dynamic行记录格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CHAR的行结构存储"><span class="nav-number">1.3.5.</span> <span class="nav-text">CHAR的行结构存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB数据页结构"><span class="nav-number">1.4.</span> <span class="nav-text">InnoDB数据页结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Header"><span class="nav-number">1.4.1.</span> <span class="nav-text">File Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#User-Record和Free-Space"><span class="nav-number">1.4.2.</span> <span class="nav-text">User Record和Free Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page-Directory"><span class="nav-number">1.4.3.</span> <span class="nav-text">Page Directory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Trailer"><span class="nav-number">1.4.4.</span> <span class="nav-text">File Trailer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB数据页结构示例分析"><span class="nav-number">1.4.5.</span> <span class="nav-text">InnoDB数据页结构示例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Named-File-Formats机制"><span class="nav-number">1.5.</span> <span class="nav-text">Named File Formats机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束"><span class="nav-number">1.6.</span> <span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据完整性"><span class="nav-number">1.6.1.</span> <span class="nav-text">数据完整性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙九博</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
