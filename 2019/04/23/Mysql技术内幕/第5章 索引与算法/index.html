<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="第5章 索引与算法一些开发人员总是事后才想起添加索引——我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。 DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需要的时间，并且可能会遗漏一部分的索引。">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章 索引与算法">
<meta property="og:url" content="https://SunJiubo.github.io/2019/04/23/Mysql技术内幕/第5章 索引与算法/index.html">
<meta property="og:site_name" content="NineBoy&#39;s Blog">
<meta property="og:description" content="第5章 索引与算法一些开发人员总是事后才想起添加索引——我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。 DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需要的时间，并且可能会遗漏一部分的索引。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-28T14:08:45.536Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5章 索引与算法">
<meta name="twitter:description" content="第5章 索引与算法一些开发人员总是事后才想起添加索引——我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。 DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需要的时间，并且可能会遗漏一部分的索引。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://SunJiubo.github.io/2019/04/23/Mysql技术内幕/第5章 索引与算法/">





  <title>第5章 索引与算法 | NineBoy's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NineBoy's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://SunJiubo.github.io/2019/04/23/Mysql技术内幕/第5章 索引与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="孙九博">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/quan.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NineBoy's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第5章 索引与算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-23T20:34:23+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第5章-索引与算法"><a href="#第5章-索引与算法" class="headerlink" title="第5章 索引与算法"></a>第5章 索引与算法</h2><p>一些开发人员总是事后才想起添加索引——我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。</p>
<p>DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需要的时间，并且可能会遗漏一部分的索引。<br><a id="more"></a></p>
<h3 id="InnoDB存储引擎索引概述"><a href="#InnoDB存储引擎索引概述" class="headerlink" title="InnoDB存储引擎索引概述"></a>InnoDB存储引擎索引概述</h3><p>前面已经提到过，InnoDB存储引擎支持的哈希索引是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<p>B+树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引。</p>
<p>另一个常常被DBA忽视的问题是：B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>在前面的章节中，每页Page Directory中的槽是按照逐渐的顺序存放的，对于某一条具体记录的查询是通过Page Directory进行二分查找得到的。</p>
<h4 id="二叉查找树和平衡二叉树（ALV树）"><a href="#二叉查找树和平衡二叉树（ALV树）" class="headerlink" title="二叉查找树和平衡二叉树（ALV树）"></a>二叉查找树和平衡二叉树（ALV树）</h4><p>平衡二叉树的查找性能是比较高的，但不是最高的，只是接近最高性能。最好的性能需要建立一棵最优二叉树，但是最优二叉树的建立和维护需要大量的操作，因此，用户一般只需建立一棵平衡二叉树即可。</p>
<p>当一棵平衡二叉树插入一个新的节点后，平衡二叉树需要做旋转操作。</p>
<p>因此对一棵平衡二叉树的维护是有一定开销的，不过平衡二叉树多用于内存结构对象，因此维护的开销相对较小。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树由B树和索引顺序访问方法（ISAM，是不是很熟悉？对，这也是MyISAM引擎最初参考的数据结构）演化而来，但是在现实使用中几乎已经没有使用B树的情况了。</p>
<p>这里，我来精简地对B+树做个介绍：B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。在B+树种，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接（双向链表）。先来看一个B+树，其高度为2，每页可存放4条记录，扇出（fan out）为5。</p>
<h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><table border="1"><tr><th>Leaf Page满</th><th>Index Page满</th><th>操作</th></tr><tr><td>No</td><td>No</td><td>直接将记录插入到叶子节点</td></tr><tr>    <td>Yes</td><td>No</td><td>1. 拆分Leaf Page；2. 将中间的节点放入到Index Page中；3. 小于中间节点的记录放左边； 4. 大于或等于中间节点的记录放右边</td></tr><tr><td>Yes</td><td>Yes</td><td>1. 拆分Leaf Page；2. 小于中间节点的记录放左边；3. 大于或等于中间节点的记录放右边；4.拆分Index Page；5. 小于中间节点的记录放左边；6. 大于中间节点的记录放右边；7. 中间节点放入上一层Index Page</td></tr></table>

<p>但是为了保持平衡对于新插入的键值可能需要做大量的拆分页（split）操作。因为B+树结构主要用于磁盘，页的拆分意味着磁盘的操作，所以应该在可能的情况下尽量减少页的拆分操作。因此，B+树同样提供了类似于平衡二叉树的旋转功能。</p>
<p>旋转发生在Leaf Page已经满，但是其的左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所有页的兄弟节点上。在通常情况下，左兄弟会被首先检查用来做旋转操作。</p>
<h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><p>B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。</p>
<table border="2"><tr><th>叶子节点小于填充因子</th><th>中间节点小于填充因子</th><th>操作</th></tr><tr><td>No</td><td>No</td><td>直接将记录从叶子节点删除，如果该节点还是Index Page的节点，用该节点的右节点代替</td></tr><tr>    <td>Yes</td><td>No</td><td>合并叶子结点和它的兄弟节点，同时更新Index Page</td></tr><tr><td>Yes</td><td>Yes</td><td>1. 合并叶子节点和它的兄弟节点 2. 更新Index Page 3. 合并Index Page和它的兄弟节点</td></tr></table>

<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>前面讨论过的都是B+树的数据结构及其一般操作，B+树索引的本质就是B+树在数据库中的实现。但是B+索引在数据库中有一个特点是高扇出性，因此在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械磁盘每秒至少可以做100次IO，2~4次的IO意味着查询时间只需0.02~0.04秒。</p>
<p>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。</p>
<p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。</p>
<p>此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。</p>
<p>通过以上对非数据页节点的分析，可以发现数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。</p>
<p>所以，聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：一是前面说过的页通过双向链表链接，页按照主键的顺序排序；另一个是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p>
<p>聚集索引的另一个好处是，它对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户索要查询的数据。如用户需要查询一张注册用户的表，查询最后注册的10位用户，由于B+树索引是双向链表，用户可以快速找到最后一个数据页，并取出10条记录。若用命令EXPLAIN进行分析，可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN</span><br><span class="line">    -&gt; SELECT * FROM Profile ORDER BY id LIMIT 10\G;</span><br></pre></td></tr></table></figure>
<p>可以看到虽然使用ORDER BY对行记录进行排序，但是在实际过程中并没有进行所谓的filesort操作，而这就是因为聚集索引的特点。</p>
<p>注意rows代表的是一个预估值不是确切的值，如果实际执行这句SQL的查询，实际只有9946条记录。</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>对于辅助索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页。</p>
<p>对于其他的一些数据库，如Microsoft SQL Server数据库，其有一种称为堆表的表类型，即行数据的存储按照插入的顺序存放。<br>堆表的特性决定了堆表上的索引都是非聚集的，主键与非主键的区别只是是否唯一且非空（NOT NULL）。因此这时书签是一个行标识符（Row Identifier，RID），可以用如“文件号：页号：槽号”的格式来定位实际的行数据。</p>
<p>有的Microsoft SQL Server数据库DBA问我这样的问题，为什么在Microsoft SQL Server数据库上还要使用索引组织表？堆表的书签使非聚集查找可以比主键书签方式更快，并且非聚集可能在一张表中存在多个，我们需要对多个非聚集索引进行查找。而且对于非聚集索引的离散读取，索引组织表上的非聚集索引会比堆表上的聚集索引慢一些。</p>
<p>当然，在一些情况下，使用堆表的确会比索引组织表更快，但是我觉得大部分原因是由于存在OLAP（On-Line Analytical Processing，在线分析处理）的应用。其次就是前面提到的，表中数据是否需要更新，并且更新是否影响到物理地址的变更。此外另一个不能忽视的是对于排序和范围查找，索引组织表通过B+树的中间节点就可以找到要查找的所有页，然后进行读取，而堆表的特性决定了这对其是不能实现的。最后，非聚集索引的离散读，的确存在上述的情况，但是一般的数据库都通过实现预读（read ahead）技术来避免多次的离散读操作。因此具体是建堆表还是索引组织表，这取决于应用，不存在哪个更优的问题。</p>
<p>图5-16显示了表t中辅助索引idx_c和聚集索引的关系。可以看到辅助索引的叶子节点中包含了列c的值和主键的值。因为这里我特意将键值设为负值，所以会发现-1以7f ff ff ff的方式进行内部存储。7（0111）最高位为0，代表负值，实际的值应该取反后加1，即得-1。（第200页的图5-16辅助索引分析非常直观！！！）</p>
<h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>B+树索引页的分裂并不总是从页的中间记录开始，这样可能会导致页空间的浪费。例如下面的记录：1、2、3、4、5、6、7、8、9。</p>
<p>插入是根据自增顺序进行的，若这时插入10这条记录后需要进行页的分裂操作，那么根据5.3.1节介绍的分裂方法，会将记录5作为分裂点记录（split record），分裂后得到下面两个页：P1：1、2、3、4 P2：5、6、7、8、9、10。</p>
<p>然而由于插入是顺序的，P1这个页中将不会再有记录被插入，从而导致空间的浪费。而P2又会再次进行分裂。</p>
<p>InnoDB的Page Header中有以下几个部分用来保存插入的顺序信息：PAGE_LAST_INSERT、PAGE_DIRECTION、PAGE_N_DIRECTION。</p>
<p>通过这些信息，InnoDB可以决定是向左还是向右进行分裂，同时决定将分裂点记录为哪一个。若插入是随机的，则取页的中间记录作为分裂点的记录，这和之前介绍的相同。若往同一方向进行插入的记录数量为5，并且目前已经定位（cursor）到的记录之后还有3条记录，则分裂点的记录为定位到的记录后的第三条记录，否则分裂点记录就是待插入的记录。**</p>
<p>对于图5-19的情况，分裂点就为插入记录本身，向右分裂后仅插入记录本身，这在自增插入时是普遍存在的一种情况。</p>
<h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><ol>
<li>索引管理</li>
</ol>
<p>通过ALTER TABLE创建索引的语法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE tbl_name</span><br><span class="line">| ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option] ...</span><br><span class="line"></span><br><span class="line">ALTER TABLE tbl_name</span><br><span class="line">DROP PRIMARY KEY</span><br><span class="line">| DROP &#123;INDEX|KEY&#125; index_name</span><br></pre></td></tr></table></figure>
<p>CREATE/DROP INDEX的语法同样很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE [UNIQUE] INDEX index_name</span><br><span class="line">[index_type]</span><br><span class="line">ON tbl_name (index_col_name,...)</span><br><span class="line"></span><br><span class="line">DROP INDEX index_name ON tbl_name</span><br></pre></td></tr></table></figure>
<p>用户可以设置对整个行的数据进行索引，也可以只索引一个列的开头部分数据，如前面创建的表t，列b为varchar(8000)，但是用户可以只索引前100个字节，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE t</span><br><span class="line">    -&gt; ADD KEY idx_b (b(100));</span><br></pre></td></tr></table></figure>
<p>通过命令SHOW INDEX FROM可以观察到表t上有4个索引，分别为主键索引、c列上的辅助索引、b列的前100字节构成的辅助索引，以及（a、c）的联合辅助索引。接着具体阐述命令SHOW INDEX展现结果中每列的含义。</p>
<p>Seq_in_index：索引中该列的位置，如果看联合索引idx_a_c就比较直观了。</p>
<p>Collation：列以什么方式存储在索引中。可以是A或NULL。B+树索引总是A，即排序的。如果使用了Heap存储引擎，并且建立了Hash索引，这里就会显示NULL了。因为Hash根据Hash桶存放索引数据，而不是对数据进行排序。</p>
<p>Cardinality：非常关键的值，表示索引中唯一值得数目的估计值。Cardinality表的行数应尽可能接近1，如果非常小，那么用户需要考虑是否可以删除此索引。</p>
<p>Sub_part：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示只对列的前100字符进行索引。如果索引整个列，则该字段为NULL。</p>
<p>Cardinality值非常关键，优化器会根据这个值来判断是否使用这个索引。但是这个值并不是实时更新的，即并非每次索引的更新都会更新该值，因为这样代价太大了。因此这个值是不太准确的，只是一个大概的值。上面显示的结果主键的Cardinality为2，但是很显然我们的表中有4条记录，这个值应该是4。如果需要更新索引Cardinality的信息，可以使用ANALYZE TABLE命令。</p>
<p>Cardinality为NULL，在某些情况下可能会发生索引建立了却没有用到的情况。这时最好的解决办法就是做一次ANALYZE TABLE的操作。因此我建议在一个非高峰时间，对应用程序下的几张核心表做ANALYZE TABLE操作，这能使优化器和索引更好地为你工作。</p>
<ol start="2">
<li>Fast Index Creation</li>
</ol>
<p>MySQL 5.5版本之前存在的一个普遍被人诟病的问题是MySQL数据库对于索引的添加或者删除的这类DDL操作，MySQL数据库的操作过程为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先创建一张新的临时表，表结构为通过命令ALTER TABLE新定义的结构。</span><br><span class="line">然后把原表中数据导入到临时表。</span><br><span class="line">接着删除原表。</span><br><span class="line">最后把临时表重名为原来的表名。</span><br></pre></td></tr></table></figure>
<p>可以发现，若用户对于一张大表进行索引的添加和删除操作，那么这会需要很长的时间。更关键的是，若有大量事务需要访问正在被修改的表，这意味着数据库服务不可用。而这对于Microsoft SQL Server或Oracle数据库的DBA来说，MySQL数据库的索引维护始终让他们感觉非常痛苦。</p>
<p>InnoDB存储引擎从InnoDB 1.0.x版本开始支持一种称为Fast Index Creation（快速索引创建）的索引创建方式——简称FIC。</p>
<p>对于辅助索引的创建，InnoDB存储引擎会对创建索引的表加上一个S锁。在创建的过程中，不需要重建表，因此速度较之前提高很多，并且数据库的可用性也得到了提高。删除辅助索引操作就更简单了，InnoDB存储引擎只需更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。</p>
<p>由于FIC在索引的创建的过程中对表加上了S锁，因此在创建的过程中只能对该表进行读操作，若有大量的事务需要对目标表进行写操作，那么数据库的服务同样不可用。此外，FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。</p>
<ol start="3">
<li>Online Schema Change</li>
</ol>
<p>所谓“在线”是指在事务的创建过程中，可以有读写事务对表进行操作，这提高了原有MySQL数据库在DDL操作时的并发性。</p>
<p>Facebook采用PHP脚本来实现OSC，而并不是通过修改InnoDB存储引擎源码的方式。</p>
<p>实现OSC步骤如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">init，即初始化阶段，会对创建的表做一些验证工作，如检查表是否有主键，是否存在触发器或者外键等。</span><br><span class="line"></span><br><span class="line">createCopyTable，创建和原始表结构一样的新表</span><br><span class="line"></span><br><span class="line">alterCopyTable，对创建的新表进行ALTER TABLE操作，如添加索引或列等</span><br><span class="line"></span><br><span class="line">createDeltasTable，创建deltas表，该表的作用是为下一步创建的触发器所使用。之后对原表的所有DML操作会被记录到createDeltasTable中</span><br><span class="line"></span><br><span class="line">createTriggers，对原表创建INSERT、UPDATE、DELETE操作的触发器。触发操作产生的记录被写入到deltas表。</span><br><span class="line"></span><br><span class="line">startSnpshotXact，开始OSC操作的事务。</span><br><span class="line"></span><br><span class="line">selectTableInfoOutfile，将原表中的数据写入到新表。为了减少对原表的锁定时间，这里通过分片（chunked）将数据输出到多个外部文件，然后将外部文件的数据导入到copy表中。分片的大小可以指定，默认值是500 000。</span><br><span class="line"></span><br><span class="line">dropNCIndexs，在导入到新表前，删除新表中所有的辅助索引。</span><br><span class="line"></span><br><span class="line">loadCopyTable，将导出的分片文件导入到新表。</span><br><span class="line"></span><br><span class="line">replayChanges，将OSC过程中原表DML操作的记录应用到新表中，这些记录被保存在deltas表中。</span><br><span class="line"></span><br><span class="line">recreateNCIndexs，重新创建辅助索引。</span><br><span class="line"></span><br><span class="line">replayChanges，再次进行DML日志的回放操作，这些日志是在上述创建辅助索引过程中新产生的日志。</span><br><span class="line"></span><br><span class="line">swapTables，将原表和新表交换名字，整个操作需要锁定2张表，不允许新的数据产生。由于改名是一个很快的操作，因此阻塞的时间非常短。</span><br></pre></td></tr></table></figure>
<p>上述只是简单介绍了OSC的实现过程，实际脚本非常复杂，仅OSC的PHP核心代码就有2200多行，用到的MySQL InnoDB的知识点非常多，建议DBA和数据库开发人员尝试进行阅读，这有助于更好地理解InnoDB存储引擎的使用。</p>
<p>由于OSC是一个PHP脚本，因此汽油一定的局限性。例如其要求进行修改的表一定要有主键，且表本身不能存在外键和触发器，此外，再进行OSC过程中，允许SET sql_bin_log=0，因此所做的操作不会同步到slave服务器，可能导致主从不一致的情况。</p>
<ol start="4">
<li>Online DDL</li>
</ol>
<p>MySQL 5.6版本开始支持Online DDL操作，其允许辅助索引创建的同时，还允许其他诸如INSERT、UPDATE、DELETE这类DML操作，这极大地提高了MySQL数据库在生产环境中的可用性。</p>
<p>此外，不仅是辅助索引，以下这几类DDL操作都可以通过“在线”的方式进行操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">辅助索引的创建与删除</span><br><span class="line">改变自增长值</span><br><span class="line">添加或删除外键约束</span><br><span class="line">列的重命名</span><br></pre></td></tr></table></figure>
<p>通过新的ALTER TABLE语法，用户可以选择索引的创建方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name</span><br><span class="line">| ADD &#123;INDEX|KEY&#125; [index_name]</span><br><span class="line">[index_type] (index_col_name,...) [index_option] ...</span><br><span class="line">ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</span><br><span class="line">LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure>
<p>ALGORITHM指定了创建或删除索引的算法，COPY表示按照MySQL 5.1版本之前的工作模式，即创建临时表的方式。INPLACE表示索引创建或删除操作不需要创建临时表。</p>
<p>在EXCLUSIVE模式下，执行索引创建或删除操作时，对目标表加上一个X锁。读写事务都不能进行，因此会阻塞所有的线程，这和COPY方式运行得到的状态相似，但是不需要像COPY方式那样创建一张临时表。</p>
<p>DEFAULT模式首先会判断当前操作是否可以使用NONE模式，若不能，则判断是否可以使用SHARE模式，最后判断是否可以使用EXCLUSIVE模式。也就是说DEFAULT会通过判断事务的最大并发性来判断执行DDL的模式。</p>
<p>InnoDB实现Online DDL的原理是在执行创建或者删除操作的同时，将INSERT、UPDATE、DELETE这类DML操作日志写入到一个缓存中。待完成索引创建后再将重做应用到表上，以此达到数据的一致性。这个缓存的大小由参数innodb_online_alter_log_max_size控制，默认的大小为128MB。</p>
<p>需要注意的是，由于Online DDL在创建索引完成后再通过重做日志达到数据库的最终一致性，这意味着在索引创建过程中，SQL优化器不会选择正在创建中的索引。</p>
<h3 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h3><h4 id="什么是Cardinality"><a href="#什么是Cardinality" class="headerlink" title="什么是Cardinality"></a>什么是Cardinality</h4><p>对于什么时候添加B+树索引，一般的经验是，在访问表中很少一部分时使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，称为低选择性。</p>
<p>相反，如果某个字段的取值范围很广，几乎没有重复，即属于高选择性，则此时使用B+树索引是最适合的。例如，对于姓名字段，基本上在一个应用中不允许重名的出现。</p>
<p>怎样查看索引是否是高选择性的呢？可以通过SHOW INDEX结果中的列Cardinality来观察。Cardinality值非常关键，表示索引中不重复记录数量的预估值。同时需要注意的是，Cardinality是一个预估值，而不是一个准确值，基本上用户也不可能得到一个准确的值。在实际应用中，Cardinality/n_rows_in_table应尽可能地接近1.如果非常小，那么用户需要考虑是否还有必要创建这个索引。</p>
<h4 id="InnoDB存储引擎的Cardinality统计"><a href="#InnoDB存储引擎的Cardinality统计" class="headerlink" title="InnoDB存储引擎的Cardinality统计"></a>InnoDB存储引擎的Cardinality统计</h4><p>因为MySQL数据库中有各种不同的存储引擎，而每种存储引擎对于B+树索引的实现又各不相同，所以对Cardinality的统计是放在存储引擎层进行的。<br>因此，数据库对于Cardinality的统计都是通过采样（Sample）的方法来完成的。<br>因此，InnoDB存储引擎内部对更新Cardinality信息的策略为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">表中1/16的数据已发生过变化。</span><br><span class="line">stat_modified_counter&gt;2 000 000 000</span><br></pre></td></tr></table></figure>
<p>第二种情况考虑的是，如果对表中某一行数据频繁地进行更新操作，这时表中的数据实际并没有增加，实际发生变化还是这一行数据，则第一种更新策略就无法适用这种情况。故在InnoDB内部有一个计数器stat_modified_counter，用来表示发生变化的次数，当stat_modified_counter大于2 000 000 000时，则同样需要更新Cardinality信息。</p>
<p>默认InnoDB对8个叶子节点（Leaf Page）进行采样。采样的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">取得B+树索引页中叶子节点的数量，记为A</span><br><span class="line"></span><br><span class="line">随机取得B+树索引中的8个叶子节点。统计每个页不同记录的个数，即为P1, P2, …, P8.</span><br><span class="line"></span><br><span class="line">根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+…+P8） * A/8</span><br></pre></td></tr></table></figure>
<p>可以看到，第二次运行SHOW INDEX FROM语句时，表OrderDetails中索引的Cardinality值都发生了变化，虽然表OrderDetails本身并没有发生任何的变化，但是，由于Cardinality是对随机取8个叶子节点进行分析，所以即使表没有发生变化，用户观察到的索引Cardinality值还是会发生变化，这本身并不是InnoDB存储引擎的Bug，只是随机采样而导致的结果。若表的叶子节点小于等于8个，这时即使随机采样，也总是会采取到这些页，每次得到的Cardinality值是相同的。</p>
<p>例如某页中索引记录为NULL、NULL、1、2、2、3、3、3，在参数innodb_stats_method的默认设置下，该页的Cardinality为4；若参数innodb_stats_method为nulls_unequal，则该页的Cardinality为5；若参数innodb_stats_method为nulls_ignored，则Cardinality为3。</p>
<p>当执行SQL语句ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX以及访问INFORMATION_SCHEMA架构下的表TABLES和STATISTICS时会导致InnoDB存储引擎去重新计算索引的Cardinality值。若表中的数据量非常大，并且表中存在多个辅助索引时，执行上述这些操作可能会非常慢。虽然用户可能并不希望去更新Cardinality值。</p>
<h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><h4 id="不同应用中B-树索引的使用"><a href="#不同应用中B-树索引的使用" class="headerlink" title="不同应用中B+树索引的使用"></a>不同应用中B+树索引的使用</h4><p>OLTP应用中，B+树索引建立后，对该索引的使用应该只是通过该索引取得表中表中少部分的数据。这是建立B+树是有意义的，否则及时建立了，优化器也可能选择不适用索引。</p>
<p>OLAP中，都需要访问表中大量的数据，根据这些数据来产生查询的结果，这些查询多是面向分析的查询，目的是为决策者提供支持。因此在OLAP中索引的添加根据的应该是宏观的信息，而不是微观，因为最终要得到的结果是提供给决策者的。但是对于OLAP中复杂查询，要设计多张表之间的连接操作，因此索引的添加依然有意义，但是如果连接操作使用的是Hash Join，那么索引可能又变的不是那么重要了。不过在OLAP应用中，通常会需要对时间字段进行索引，这是因为大多数同级需要根据时间维度来进行数据的筛选。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>是指对边上的多个列进行索引。</p>
<p>联合索引的创建方法与单个索引创建的方法一样，不同之处进在于多个索引列。</p>
<p>联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2.</p>
<p>对于查询中where a=xxx and b=xxx显然是可以使用(a,b)这个联合索引的。对于where a=xxx,也可以使用这个联合索引，但是对于where b=xxx,则不可以使用这个B+树索引。</p>
<p>联合索引的第二个好处是已经对第二个键值进行了排序处理，可以避免多一次的排序操作，因为索引本身在叶子节点已经排序了。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>InnoDB支持覆盖索引，即从辅助索引中就可以得到查询的结果，而不需要查询聚集索引的记录。<br>使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，顾其大小都远小于聚集索引，因此可以减少大量的IO操作。</p>
<p>对于InnoDB而言，由于其包含了主键信息，因此其叶子节点存放的数据为(primary key1,primary key2,…,key1,key2,…)</p>
<p>另一个好处是是对某些统计问题而言。</p>
<h4 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h4><p>在某些情况下，当执行EXPLAIN命令进行SQL语句分析时，会发现优化器并没有选择索引去查找数据，而是通过扫面聚集索引，也就是直接进行全表的扫描来得到数据。</p>
<p>用户要选取的数据时整行数据，而OrderID索引不能覆盖到我们要查询的数据，因此在对OrderID索引查询到指定数据后，还需要一次书签访问来查找整行数据的信息。虽然OrderID索引中数据时顺序存放的，但是再一次进行书签查找的数据则是无序的，因此变味了磁盘上的离散读操作。如果要求访问的数据量很大，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般为20%左右），优化器会选择通过聚集索引来查找数据。因为之前已经提过，顺序读要远远快于离散读。</p>
<p>因此对于不能使用索引覆盖的情况，优化器选择辅助索引的情况是，通过辅助索引查找的数据是少量的。这是有当前传统机械硬盘的特性所决定的，即利用顺序读来替代随机读的查找。</p>
<h4 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h4><p>MySQL数据库支持索引提示，显示的告诉优化器使用哪个索引</p>
<p>以下两种情况可能用到INDEX HINT：</p>
<ol>
<li>MySQL数据库的优化器错误的选择了某个索引，导致SQL语句运行的很慢。这种情况在最新的MYSQL中很少见。优化器在绝大部分情况下工作得都非常有效和正确。这时有奖演的DBA或开发人员可以强制优化器使用某个索引来提高sql的运行速度</li>
<li>某sql语句可以选择的索引非常多，这时优化器选择执行时间的开销可能会大于sql语句本身。例如优化器分析Range查询本身就是比较耗时的操作。这时DBA或开发人员分析最有的索引选择，通过Index Hint来强制使用优化器不进行各个执行路径的成本分析，直接选择指定的索引来完成查询。</li>
</ol>
<p>如果用户确定指定某个索引来完成查询，那么最可靠的是使用FORCE INDEX，而不是USE INDEX。后者只是建议优化器使用某个索引。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/22/面试题/面试题第三周/" rel="next" title="面试题第三周">
                <i class="fa fa-chevron-left"></i> 面试题第三周
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/29/面试题/面试题第四周/" rel="prev" title="面试题第四周">
                面试题第四周 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/quan.jpg" alt="孙九博">
            
              <p class="site-author-name" itemprop="name">孙九博</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章-索引与算法"><span class="nav-number">1.</span> <span class="nav-text">第5章 索引与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB存储引擎索引概述"><span class="nav-number">1.1.</span> <span class="nav-text">InnoDB存储引擎索引概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构与算法"><span class="nav-number">1.2.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">1.2.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树和平衡二叉树（ALV树）"><span class="nav-number">1.2.2.</span> <span class="nav-text">二叉查找树和平衡二叉树（ALV树）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">1.3.</span> <span class="nav-text">B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树的插入操作"><span class="nav-number">1.3.1.</span> <span class="nav-text">B+树的插入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树的删除操作"><span class="nav-number">1.3.2.</span> <span class="nav-text">B+树的删除操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树索引"><span class="nav-number">1.4.</span> <span class="nav-text">B+树索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚集索引"><span class="nav-number">1.4.1.</span> <span class="nav-text">聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助索引"><span class="nav-number">1.4.2.</span> <span class="nav-text">辅助索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树索引的分裂"><span class="nav-number">1.4.3.</span> <span class="nav-text">B+树索引的分裂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树索引的管理"><span class="nav-number">1.4.4.</span> <span class="nav-text">B+树索引的管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cardinality值"><span class="nav-number">1.5.</span> <span class="nav-text">Cardinality值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是Cardinality"><span class="nav-number">1.5.1.</span> <span class="nav-text">什么是Cardinality</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB存储引擎的Cardinality统计"><span class="nav-number">1.5.2.</span> <span class="nav-text">InnoDB存储引擎的Cardinality统计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树索引的使用"><span class="nav-number">1.6.</span> <span class="nav-text">B+树索引的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#不同应用中B-树索引的使用"><span class="nav-number">1.6.1.</span> <span class="nav-text">不同应用中B+树索引的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联合索引"><span class="nav-number">1.6.2.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖索引"><span class="nav-number">1.6.3.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化器选择不使用索引的情况"><span class="nav-number">1.6.4.</span> <span class="nav-text">优化器选择不使用索引的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引提示"><span class="nav-number">1.6.5.</span> <span class="nav-text">索引提示</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙九博</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
